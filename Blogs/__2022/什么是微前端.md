# 什么是微前端

本篇想来聊一聊微前端，不会讲得很细，也不会讲到源码级别的解析，但会把我了解的微前端都讲一讲，可以算是一篇扫盲篇吧

读完本篇，你能了解到：

- **什么是微前端？**
- **常见的微前端方案？**
- **什么时候该用微前端，它用来解决什么问题？**
- **微前端具有哪些特性？**
- **微前端为什么会拥有这些特性？（即框架内部做了些什么）**
  - 比如 qiankun 框架内部都做了些什么事？
  - 比如 single-spa 框架是什么？import-html-entry 框架又是什么？

## 什么是微前端

理解微前端，可以从两个角度来看，一个是用户角度，一个是开发角度。

从用户角度来看，他只需要跟一个应用打交道即可。

但从开发角度来看，服务用户的这个应用其实是个巨无霸，由多个不同业务的子应用集合而成。

简单来说就是，**对外是单一应用形态，对内则是各个相互独立的子应用集合而成**。那么，这种架构思想就是微前端思想。

比如美团 APP，对用户来说就是一个美团应用而已，但其实它内部包括了外卖、酒店、电影、打车等等业务独立的子应用。

再比如大多数的 B 端后台系统，如阿里云网站，包括了云服务器、域名、数据库、订单等各个子系统。

了解完微前端思想，接下去就来看看它的落地方案

## 常见的微前端方案

微前端方案其实有很多种，比如说：

- **APP 容器化(WebView)方案**

这是一种非前端的方案，有了解过 Cordova 跨平台前端 APP 方案的，对这个应该就不陌生。

借助 APP 原生能力，每个子应用激活运行时，都重新拉起一个新的容器(WebView)来运行，有点类似于浏览器另起标签页方式。

- **iframe 方案**

这种方案其实很早就在用了，比如某些学校的老旧教务系统。

在页面某块区域挂载一个 iframe 块，来加载当前处于激活运行状态的子应用。

- **Nginx 方案**

这也是一种挺常见的方案，因为实现成本简单。

借助 Nginx，解析不同路由时，反向代理到不同子应用站点上。

- **npm 包方案**

这是一种借助工程构建能力的方案，把子应用当作一个三方包来集成到主应用里去。

- **SPA 方案（qiankun, single-spa)**⭐️

这是一种让应用保持有单页应用优势的同时，也能够集成其他子应用的方案。

网上常说的微前端大多都是指这种方案，因为上面其他几种微前端方案多多少少都有一些无法解决的局限性问题，比如 iframe 方案的路由丢失、弹窗遮罩问题，比如 Nginx 方案的页面刷新体验问题。

所以如何在单页应用里，把其他子应用集成进来，并且大家共享同一个运行时又能够不相互影响，这个就是微前端框架要做的事。

比如 single-spa 框架解决了如何根据路由来管理不同子应用的生命周期状态。

比如 qiankun 框架基于 single-spa 基础上，实现了子应用集成、子应用运行隔离等处理。

***

总之，微前端方案有很多种，有用前端实现的、也有非前端实现的，有针对 PC 的、也有针对 APP 的，有适用于在线场景的、也有适用于离线场景的，而且每一种方案里也有很多热门的现成框架。

所以，有的时候，一些所谓的微前端最佳实践方案并不一定就是适用于你的实际项目背景的。

在实际开发中，往往抉择某个方案时，考虑的因素有很多（诉求、成本、资源、时间、技术、扩展等），综合下来，只有性价比最优的方案，但这方案不一定是社区里的最佳实践方案，所以没必要人云亦云，清楚自己的诉求，选择适合自己的方案即可

## 什么时候该用微前端？它用来解决什么问题？

当你会来问这个问题时，其实这也意味着你目前可能还不是很需要微前端来帮你解决问题。

通常会有两类场景比较需要使用到微前端：

- **多团队共同维护同个产品的场景（巨石应用场景）**
- **技术栈繁杂的场景**

多团队维护同个产品的起源往往都是因为业务发展过快，因为赚钱快，所以公司不断招人，人一多就会开始分团队，团队一分，那两波人就是相互独立的节奏了，业务、需求、发版等都是各自团队的节奏。

那么，如果这时候，大家还是在同一个项目仓库里开发，问题就会越来越大，因为耦合度太大了，相互间影响点太多了，这种场景其实也就是常说的**巨石应用**场景，巨石应用最大的问题就是，一个小小的改动，都需要重新构建、发布整个巨石应用。

这时候，就很需要用微前端思想来解决问题了，把巨石应用里这一个个业务模块独立成子应用出来交由不同团队独立去维护，但这个过程理应是要对用户无感的，所以对外还需要保持同个应用。那这不就是微前端思想。

而当产品越做越大时，总会有需要集成其他子产品的时候，而这过程，往往就会产生技术栈繁杂的情况，因为前端技术发展实在是太快了，集成进来的子产品有可能是老产品，也有可能是新产品，那么这横跨几年的项目技术栈方面很难做到统一的。那么不同技术栈的集成，只能走微前端思想来进行。

***

其实，更通俗一点来说的话，如果你的项目只有一个团队寥寥几人开发，那么这时候，往往还不需要去考虑微前端，因为微前端能给你带来的价值体现并不是很明显，顶多只能说是未来的潜在价值

但当你看着你的团队人数不断增加、开始划分产品线，划分团队管理，而且对外销售仍保持单一产品时，这时候，就可以考虑微前端了

为什么？因为如果不把各团队的产品线代码独立出去的话，你会发现，越来越容易发生事故了，因为不清楚哪个团队的哪次发布就会影响到你的产品功能。这时候你会发现，工作上耗费太多精力在这些上面了，而且产品也越来越不稳定了。

所以，微前端用来解决的，其实是开发内部的问题，独立开发、部署来提高产品稳定性，降低事故风险，减少跨团队维护成本

## 微前端具有哪些特性？

不同微前端方案所带来的特性也所有不同，从这一节开始，我们讲的内容都是针对 qiankun 这类 SPA 微前端方案来展开

所以，下面盗用 qiankun 官网的特性介绍（只截取了部分特性）：

- 📱 **技术栈无关**，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。
- 💪 **HTML Entry 接入方式**，让你接入微应用像使用 iframe 一样简单。
- 🛡 **样式隔离**，确保微应用之间样式互相不干扰。
- 🧳 **JS 沙箱**，确保微应用之间 全局变量/事件 不冲突。
- ⚡️ **资源预加载**，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。

看到这些特性，不清楚你们会不会跟我有同样的好奇：为什么它就能支持技术栈无关，是怎么做到的，等等。

所以下面就来简单说下，qiankun 的这个微前端框架为什么会具备以上这些特性，也就是，它内部是做了什么来支撑它具备上面这些特性

##  微前端为什么会拥有这些特性？（即框架内部做了些什么）

![image-20220505231054017](/Users/suxq/Library/Application Support/typora-user-images/image-20220505231054017.png)

一个微前端项目的简单架构，底层都会是一个所谓的基座主框架，然后在它之上则是各个相互独立的具有完整生命周期的子应用

这些子应用之间要么是互斥状态，即同一个只能有一个处于激活状态的子应用；要么是非互斥状态，同一时刻可以同时有多个处于激活状态的子应用

但不管子应用间的关系是什么，每个子应用都是独立的，因此都有各自的生命周期、各自的路由系统

而谁来提供这些能力给他们呢，或者说谁来管理这些子应用的各种关系、各种生命周期、各种路由事件呢？

自然就是大家都依赖的基座主框架

而落到 SPA 单页应用里，就还需要多出一个处理：如何在运行期间隔离不同子应用，因为单页应用是不刷新页面共享运行时的

所以，明白了 qiankun 官网介绍的它所具备的这些特性了吧，归类一下，无非就是指子应用的集成和隔离，至于子应用的管理，qiankun 借助了 single-spa 框架来实现

概述一下，单页应用的微前端框架要做的事，其实就是：**子应用的管理、集成、隔离**

有些产品还会有子应用间的通信场景，但通信这个不是必须的，就不打算怎么展开讲了，无非就是找一个第三方作为通信桥梁

下面以 qiankun 框架为例，来简单讲讲它在这三个方面都是怎么实现的：

### 子应用的管理（single-spa）

子应用的管理其实就两个方面：

- 生命周期
- 路由分发

生命周期管理是因为同一时刻，总会有处于不同状态的子应用，比如这个被激活了，那个被卸载了等等

路由分发管理是由于大家都共享同一个标签页，共享同一个地址栏的导航事件，导航事件需要分发到合适的子应用去接管

所以，single-spa 框架内部其实也就是做了这两件事

通过重写路由相关的方法来进行路由分发，通过定义一系列子应用生命周期状态，根据不同路由事件和时机来触发子应用状态的变更

#### 路由分发管理

更详细一点来说的话，它重写相关路由监听事件的方法，把对原生路由事件的监听改写成了只是在它内部维护了一个带有当前子应用相关信息的事件回调，这样所有的子应用里对路由系统的监听其实都被拦截了，实际只是往基座主框架里注册了个回调事件

真正监听系统路由事件的，其实只有基座主应用

于是，这样就能够实现在合适的时机，去触发合适的子应用的路由回调事件，以此来达到路由分发管理的效果

#### 生命周期管理

在生命周期状态方面，single-spa 定义了多种状态，但归类下，无非就是：启动、激活、卸载这几种

如果有用过 qiankun 的是不是感觉很熟悉，因为 qiankun 就是用 single-spa 来做子应用的管理，而 single-spa 要求要接入的子应用需要对外暴露三个钩子：

- bootstrap
- mount
- unmount

这其实也正是 qiankun 框架能够支持技术栈无关的原因，这个特性其实是 single-spa 框架的特性，因为它只是当子应用满足相应规则时调用了子应用的相应生命周期钩子函数，而这个函数实际的行为由各自子应用去实现

所以 vue 技术栈的可以用 vue 的挂载卸载方案，react 技术栈的用 react，大家负责各自的挂载、卸载实现，以此就实现了技术栈无关特性

### 子应用的集成（import-html-entry）

微前端最大的价值就是子应用是独立的，独立仓库、独立开发、独立部署

这说明基座主框架的项目里是没有子应用资源的，那么就需要考虑：

- 如何把这些子应用资源集成过来？
- 子应用资源该以什么样的形态集成进来以便基座主框架能够使用？

第一个问题其实就是怎么去下载子应用的这些资源？

一种思路是子应用打包后需要生成资源清单，基座主应用拿到这份资源清单就能够知道该去下载哪些子应用资源。资源清单可以通过 webpack 的 stats-webpack-plugin 插件来生成 manifest.json 资源清单

另一种思路就是去解析子应用的入口文件 html 代码，从里面拿到各种资源清单后，再去下载。qiankun 就是用来 import-html-entry 框架来实现这种思路

import-html-entry 做的事其实也不复杂：

- 先下载并读取到子应用的 html 代码内容
- 下载 html 里的外部资源，比如 link 标签，如果是样式文件，则用 style 标签包裹样式文件代码内容，再回填到 html 上
- 注释 html 里的 script 标签，如果是内部脚步，收集起来，如果是外部脚本链接，先下载再收集
- 对外提供 api 来触发所有收集起来的 script 脚本的执行

经过 import-html-entry 处理后的 html 内容，包含了所有外部样式代码，并且注释了所有 script 标签代码，因此这份 html 内容可以直接被塞到基座主应用到某个元素标签内而不产生什么副作用，而 qiankun 激活子应用时，也正是这么做的

这个做法也正是 qiankun 所说的 HTML Entry 的接入方式，看张图你会更明白了：

// todo



### 子应用的隔离（js 沙箱、样式隔离）

由于单页应用是不刷新页面的，意味着各个子应用以及基座主应用都是共享同一个运行时，共享运行时的浏览器各内核状态

所以，为了各个子应用间，或者主应用与子应用间不会造成相互影响，需要在三个方面做好隔离处理：

- 样式
- 全局变量、全局对象
- 全局事件

样式隔离场景比较好理解，毕竟 css 的作用域机制一直是个问题，单页应用时就会出现相互影响，而建议使用 css module 来进行相互隔离了，更何况现在时多个单页应用的集成场景

全局变量的隔离通常是指 window 变量，实际开发中，经常会往 window 上挂东西，在这种多子应用共享场景下就容易出问题

全局对象的隔离通常是指 document，history，console 等这些全局共享等对象，原因跟 window 类似，实际开发中，总会去重写

全局事件则是指 addEventListener，setTimeout，setInternal 这类注册全局回调事件，因为这些回调事件跟子应用生命周期不一致，不做好处理，容易出问题

#### 样式隔离

样式隔离有几种思路，比如 web-component，但这种方案弊端在于依赖的三方库不一定有兼容这种场景

比如 css module，css namespace，但这种需要对子应用改造较多，不过实现起来简单，因为就是约定规范

qiankun 用的是动态 style 标签方案，因为 style 标签的添加或移除都会触发 CSSOM 树的重新构建，那只有子应用激活时，把子应用的所有样式添加到 style 标签里，子应用卸载时，跟着移除 style 标签，就能做到 style 样式的生命周期控制，从而不影响其他子应用

再者，由于 qiankun 依赖了 import-html-entry 框架，经过这个框架处理后的 html 内容已经把所有的样式代码回填到 style 标签内，所以是一种天然支持动态 style 标签的方案了

#### 全局变量、全局对象隔离、全局事件隔离

这个场景的隔离，qiankun 就是真正自己实现的

样式隔离

- 动态 style 标签
  - 无法解决同时运行中的应用隔离（主应用与子应用）
- css namespace 或 css module

Js 沙箱 - 解决 window 全局变量的影响

- 快照沙箱
- 代理沙箱

全局事件的隔离

- 重写 addEventListener
- document
- history
- setTimeout, setInternal
