import{_ as t,r as i,o as r,c as s,a as e,b as o,e as n,d as c}from"./app-2pyCoCP5.js";const p={},h=e("h1",{id:"讲讲前端加密和鉴权",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#讲讲前端加密和鉴权","aria-hidden":"true"},"#"),o(" 讲讲前端加密和鉴权")],-1),d=e("p",null,"本文参考：",-1),l={href:"https://juejin.im/post/5c6e4ec1e51d454c6436420f",target:"_blank",rel:"noopener noreferrer"},_={href:"https://juejin.im/post/5c6e6063f265da2da53ec8f3",target:"_blank",rel:"noopener noreferrer"},k=c('<p>客户端与服务端通信的加密和鉴权处理，无外乎就是为了保证数据的安全性、客户端的身份合理性</p><h3 id="加密" tabindex="-1"><a class="header-anchor" href="#加密" aria-hidden="true">#</a> 加密</h3><p>因为 HTTP 是明文传输，存在很多安全隐患，基于此，可以选择自行加密传输信息，也可以选择使用 HTTPS 协议</p><p>自行加密处理的话，就涉及到是对称加密还是非对称加密、密钥的管理等等问题</p><p>当然也可以通过编码方式来隐藏明文，但这仅仅是防君子不防小人，编码并不是加密，比如 BASE64，虽然明眼看不出信息，但经过解码处理下明文就又看见了</p><p>又因为用户对客户端是有很大的掌握权，运行在客户端上的代码基本都很透明，用户都可以查阅，没有什么安全性</p><p>所以，对于加密的处理，最好的方式还是使用 HTTPS 协议，其他方式，客户端都存在一个密钥泄漏的风险</p><h3 id="鉴权" tabindex="-1"><a class="header-anchor" href="#鉴权" aria-hidden="true">#</a> 鉴权</h3><p>什么是身份的鉴权呢？</p><p>简单说，服务端并不知道都会有哪些客户端与他建立连接，这些来源的身份是否合理，HTTP 又是无状态的，所以通常来说，服务端对接口的访问者都会进行身份鉴权处理，保证调这些接口都是合理的用户</p><p>在前端方向，对于服务端来说，调接口的来源可以是浏览器、可以是 Postman 这些请求工具、也可以是跑在其他服务器上的脚本</p><p>所以，通常网站都会有一个登陆系统，用户需要先进行登陆，才能访问后续的接口，这种场景下，服务端对接口的身份鉴权通常就是验证是否有登录，实现上，就是借助 session-cookie （会话 cookie），但要注意预防 CSRF 攻击</p><p>当然，还有更安全和常用的单点登录认证方式（SSO）、或者 OAuth 2.0 方式，简单来说，就是只有一个登录认证中心，但可以授权令牌给其他三方网站，访问其他网站接口时，就可以通过令牌来代表身份</p><p>但是，还有一些网站是没有登录系统，或者有些接口是允许没登录下访问的，如果这些接口又刚好不想让非法用户访问，那就还是得对访问者进行身份鉴权，这种方式通常是借助 token 方式验证</p><p>下面大概讲讲几种方式的流程：</p><h4 id="session-cookie" tabindex="-1"><a class="header-anchor" href="#session-cookie" aria-hidden="true">#</a> session-cookie</h4><ol><li>客户端使用账号密码登录系统，服务端生成会话唯一标识符，并将其通过 set-cookie 返回给客户端</li><li>客户端自动保存登录状态到 cookie 中，后续访问其他接口会自动携带上 cookie</li><li>服务端通过 cookie 验证对应会话的状态，如果登录失效，返回 401，否则成功返回数据</li></ol><h4 id="token" tabindex="-1"><a class="header-anchor" href="#token" aria-hidden="true">#</a> Token</h4><p>token 其实分两种，一种是登录成功后，由后端生成 token 下发给客户端，后续客户端访问其他接口时，都需手动带上次 token</p><p>另一种则是 token 由客户端生成，服务端再根据相同规则也生成，比对认证</p><p>第一种其实流程跟 cookie 差不多，区别就在于一个需要自己传，一个不用，但 cookie 会有 CSRF 攻击的风险</p><p>第二种则是双方需要使用相同的规则来生成 token，一旦这个规则泄漏，那就可以被伪造</p><h4 id="单点登录-sso-和-oauth" tabindex="-1"><a class="header-anchor" href="#单点登录-sso-和-oauth" aria-hidden="true">#</a> 单点登录（SSO） 和 OAuth</h4><p>这种认证方式跟前面的区别在于，登录认证的系统不是由本系统实现，本系统也没有任何关于账号的信息</p><p>调用本系统接口时，需要携带某个身份令牌，而这个身份令牌由统一登录中心生成，所以当服务端发现未登录时，需告知浏览器重定向到统一登录中心或者调用授权服务</p><p>统一登录中心登录成功后，会将身份令牌通过浏览器传给服务端，服务端可以通过 set-cookie 将这个身份令牌写入浏览器的 cookie 中，后续接口的调用，就会自动带上身份令牌</p>',26);function u(f,x){const a=i("ExternalLinkIcon");return r(),s("div",null,[h,e("blockquote",null,[d,e("ol",null,[e("li",null,[e("a",l,[o("前端面试查漏补缺--(八) 前端加密"),n(a)])]),e("li",null,[e("a",_,[o("前端面试查漏补缺--(十) 前端鉴权"),n(a)])])])]),k])}const b=t(p,[["render",u],["__file","讲讲前端加密和鉴权.html.vue"]]);export{b as default};
