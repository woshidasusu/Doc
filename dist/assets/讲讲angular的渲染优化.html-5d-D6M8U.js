import{_ as e,o as a,c as n,d as t}from"./app-XVH6qKTA.js";const c={},r=t(`<h1 id="讲讲-angular-的渲染优化" tabindex="-1"><a class="header-anchor" href="#讲讲-angular-的渲染优化" aria-hidden="true">#</a> 讲讲 angular 的渲染优化</h1><p>前端的响应式系统，也就是三大框架所实现的双向绑定，其实要解决的都是模型到视图这个方向的更新</p><p>如何知道更新的时机，以及如何确定更新的视图是哪些，就是框架层面所要解决的两个关键问题</p><p>angular 是通过对所有可能会造成界面刷新的操作都进行了一层封装，比如所有的 dom 原生事件，异步事件，setTimeout 这些都经过封装，当被调用时，angular 就认为界面有可能刷新，就会去触发它的脏数据检测机制</p><p>脏数据检测机制通俗讲就是会把模板代码里所有绑定的表达式、变量等的值重新计算一遍，然后跟上一时刻比对，当发现不一样时，说明这块视图数据脏了，那就知道了这块视图是需要更新的了</p><p>那么这个过程是如何优化的呢？</p><p>在 angular 里有组件的概念，angular 做成的单页应用，页面其实都是由组件构成，从根组件开始，不管嵌套子组件形成一颗组件树</p><p>这里的组件可以理解成是对多个原生 html 元素自定义的组合后的集合统称</p><p>每个组件都有自己对应的一个变化检测器，负责该组件的脏数据检测工作</p><p>每一次脏数据检测过程，都是从根组件开始，遍历整颗组件树，通知每个组件的变化检测器去进行相关的检测工作，体现在生命周期上，就是当前组件的 <code>ngDoCheck()</code> 先调用，然后当子组件检测结束后，会收到 <code> ngAfterViewChecked()</code> 的回调</p><p>所以，默认行为下，angular 的每一次脏数据检测过程都会遍历整颗组件树，检测每个组件</p><p>当然，支持我们根据场景修改这种检测策略来进行优化，比如有些组件你很明确的视图更新场景，那么这时候就可以通过修改策略，每一次脏检测时，遍历到该组件，就停止，不走默认策略，交由自行决定</p><p>具体做法就是，在声明组件的装饰器里通过元数据 changeDetection 修改成 onPush 的策略，这种策略只在组件输入的数据发生变化时才会触发组件的检测，否则直接跳过</p><p>然后该组件内部通过依赖注入持有 changeDetectionRef，这个服务提供几种方法，可以让开发者根据需要使用，比如有可以手动触发该组件及其子组件进行检测工作的方法，也有从变化检测树上移除不再接收检测的方法</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>export abstract class ChangeDetectorRef {
  abstract markForCheck(): void;  // 在组件的 metadata 中如果设置了 changeDetection: ChangeDetectionStrategy.OnPush 条件，那么变化检测不会再次执行，除非手动调用该方法
  abstract detach(): void; // 从变化检测树中分离变化检测器，该组件的变化检测器将不再执行变化检测，除非手动调用 reattach() 方法
  abstract detectChanges(): void;  // 重新添加已分离的变化检测器，使得该组件及其子组件都能执行变化检测
  abstract reattach(): void; // 从该组件到各个子组件执行一次变化检测
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>常见的优化处理就是，确保组件内部的数据都是通过外部输入，此时可将检测策略修改成 OnPush</p><p>这样一来，输入不变就不会触发组件的检测，但需要考虑输入是对象或数组的场景</p><p>此时，可借助不可变数据类型，每次修改对象确保生成新的对象，而不是在原对象上进行操作，这样就能让组件接收到输入变化而进行检测</p><p>这样优化后，就不会每一次的检测都遍历整颗组件树了</p>`,19),s=[r];function i(d,p){return a(),n("div",null,s)}const o=e(c,[["render",i],["__file","讲讲angular的渲染优化.html.vue"]]);export{o as default};
