import{_ as e,o as p,c as a,d as r}from"./app-Zf-yBXw2.js";const h="/assets/解决本地开发跨域问题-36qn9Dr_.png",t="/assets/解决本地开发跨域问题2-qJArKSVX.png",c="/assets/解决本地开发跨域问题3-mdFueGSc.png",s={},o=r('<p>本篇讲的是本地开发时的跨域问题，即运行类似 localhost:8080 来开发程序时，接口出现跨域的场景处理</p><p>通常，前端独立部署的项目是不会有这种问题出现的，因为前后端分开部署，本身就已经处于跨域场景，所以，后端接口基本都会在请求的返回头加上支持跨域的响应头</p><p>但在一些前端仍旧跟后端项目部署在同一站点的场景下，后端接口如果没有在响应头上加上跨域支持，那么，本地开发时，就会出现跨域问题，阻塞本地开发</p><p>解决方案有很多，随便挑一种自己熟悉、用惯的即可</p><p>解决方案的思路其实就两点：想办法不跨域；想办法支持跨域</p><h1 id="解决方案一-后端响应头加字段" tabindex="-1"><a class="header-anchor" href="#解决方案一-后端响应头加字段" aria-hidden="true">#</a> 解决方案一：后端响应头加字段</h1><p>这是对前端来说，最简单的方式，但后端估计不好处理</p><p>如果后端不处理，前端来解决本地开发跨域问题的话，终归是需要借助到代理工具（除非设置 chrome 不拦截跨域），所以，建议，一定一定要掌握一款代理工具的使用，随便你用选，webpack 的代理配置也行、whistle 更好</p><h1 id="解决方案二-代理指定域名到本地" tabindex="-1"><a class="header-anchor" href="#解决方案二-代理指定域名到本地" aria-hidden="true">#</a> 解决方案二：代理指定域名到本地</h1><p>举个例子：</p><p>将访问 <code>https://vengineer-test.myyscm.com/wework/home</code> 的请求代理到访问 <code>http://localhost:8080/wework/home</code></p><p>这样，对于浏览器来说，从头到尾都是在前者的站点下的请求，自然就不存在跨域</p><p>所以，这是一种借助代理来让本地开发不存在跨域场景的思路</p><p>具体操作可以借助 whistle 代理工具的配置，如下：</p><p><img src="'+h+'" alt=""></p><h1 id="解决方案三-配置请求拦截-响应头加上支持跨域字段" tabindex="-1"><a class="header-anchor" href="#解决方案三-配置请求拦截-响应头加上支持跨域字段" aria-hidden="true">#</a> 解决方案三：配置请求拦截，响应头加上支持跨域字段</h1><p>这是一种把后端不做的事，前端通过代理方案来做的思路</p><p>具体操作参考方案二的图片，即上图</p><p>简单说，就是随便借助一种代理工具（这里用了 whislte），然后拦截请求，并在响应头上加上支持跨域的字段，比如：</p><p><img src="'+t+'" alt=""></p><h1 id="解决方案四-配置-webpack-的-proxy-支持跨域" tabindex="-1"><a class="header-anchor" href="#解决方案四-配置-webpack-的-proxy-支持跨域" aria-hidden="true">#</a> 解决方案四：配置 webpack 的 proxy 支持跨域</h1><p>这是一种借助 webpack 来支持跨域的思路</p><p>建议把 loglevel 都设为 debug，这样才方便查看请求是否有被代理</p><p>这种方案上手简单，但不实用（一是每次修改都需要重跑服务、二是看不到具体代理的详细情况）</p><p><img src="'+c+'" alt=""></p><h1 id="解决方案五-设置-chrome-浏览器不处理跨域" tabindex="-1"><a class="header-anchor" href="#解决方案五-设置-chrome-浏览器不处理跨域" aria-hidden="true">#</a> 解决方案五：设置 chrome 浏览器不处理跨域</h1><p>这是一种简单粗暴是方案</p><p>chrome 可以通过某种手动，把跨域的限制给关闭掉，这样本地开发时，就不会有跨域问题了</p><p>具体操作方案自行网上搜索，不是很建议这种方案，虽然很简单粗暴，一劳永逸，但有时候会让你忘记提醒后端开发人员接口需要做跨域支持</p><h1 id="最后" tabindex="-1"><a class="header-anchor" href="#最后" aria-hidden="true">#</a> 最后</h1><p>跨域问题，建议还是要掌握，可以顺便自行再去了解下，为什么会有跨域，跨域怎么出现的，而且出现跨域后，有哪些方案解决</p><p>当你网上看了一堆文章后，你会发现，大伙讲的都大同小异，但讲的都是生产环境的跨域怎么解决，基本都没有人提本地开发时的跨域怎么处理</p><p>为什么不提呢？</p><p>这是默认你已经掌握并了解了什么是跨域了，当你清楚了跨域怎么来的，自然就有办法解决自己本地开发时的跨域问题</p>',34),d=[o];function i(n,_){return p(),a("div",null,d)}const m=e(s,[["render",i],["__file","解决本地开发的跨域问题.html.vue"]]);export{m as default};
