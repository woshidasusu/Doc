import{_ as p,r as d,o as n,c as s,a as e,b as o,e as c,d as a}from"./app-PjuKeMiB.js";const t={},k=e("h1",{id:"docker",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker","aria-hidden":"true"},"#"),o(" docker")],-1),i=e("p",null,"参考资料：",-1),l={href:"https://docs.docker.com/compose/reference/overview/",target:"_blank",rel:"noopener noreferrer"},h={href:"https://yeasy.gitbooks.io/docker_practice/content/",target:"_blank",rel:"noopener noreferrer"},m=a('<h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h2><p><strong>镜像</strong>： 存于 docker 仓库里的基础镜像，相当于一个文件系统，比如 nginx，alpine（最轻量级 linux 系统）</p><p><strong>容器</strong>： 基于镜像，通过 docker 命令启动的叫容器，有点类似于虚拟机，各个容器都是独立的环境</p><p><strong>服务</strong>： 服务是 docker-compose 里的概念，用于方便管理容器</p><p><strong>宿主机</strong>： docker 运行的环境称为宿主机，宿主机为各个容器提供硬件资源支持</p><p><strong>Dockerfile</strong>： 用于定制镜像的配置文件</p><p><strong>docker-compose.yml</strong>： 用于管理启动多个容器的配置文件</p><h2 id="docker-命令" tabindex="-1"><a class="header-anchor" href="#docker-命令" aria-hidden="true">#</a> docker 命令</h2><p>docker 命令可以做很多事，比如：</p><p>拉取仓库的镜像到本地（pull）；在镜像基础上启动一个容器（run）；连接并登陆正在运行中的容器（exec）；将对容器的各种操作与基础镜像一起制作成新的镜像（commit）；网络相关（network）；数据卷相关（volume）等等</p><p>所有想要通过 docker 实现的目的，都可以只用 docker 命令完成</p><p>但考虑到各种各样的原因，如维护性、复用性、方便性等等，从而除了 docker 命令外，还衍生出了很多东西：</p><p>用来方便维护、复用的定制化镜像实现（Dockerfile）；</p><p>用来方便维护、管理各容器运行参数和环境等的配置（docker-compose）；</p><p>等等</p><h2 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile" aria-hidden="true">#</a> Dockerfile</h2><p>Dockerfile 文件是用于定制镜像使用的配置文件</p><p>简单说，我们可以基于某个基础的镜像，修改镜像的某些内容</p><p>再或者说，镜像其实也就是个文件系统，我们可以往这个系统里预先丢一些文件进去，或者设置一些环境变量等等，这样来定制化制作一个符合我们需求的镜像</p><p>这些操作，原本是可以只用 docker 命令，通过在基础镜像上启动一个容器，然后进入该容器后，就类似于 ssh 一个服务器，接下去就可以做一些类似新服务器的基础搭建、如设置环境变量，预置一些文件等等</p><p>本质上，新的镜像其实是由基础镜像和容器的存储层构成</p><p>但这种做法有个缺点，就是你对这个容器做了什么，只有你知道，这样特别不便于维护，尤其你自己也很有可能忘记你都操作了什么</p><p>所以 Dockerfile 就出现了，这份文件会记载着所有对镜像的操作记录，每一行命令，就是一层容器存储层，也可以通俗理解成镜像各个时刻的快照</p><p>通过 docker build 命令，就可以在新的机器上，构建一个跟你当前环境一样的镜像出来</p><h2 id="docker-compose" tabindex="-1"><a class="header-anchor" href="#docker-compose" aria-hidden="true">#</a> docker-compose</h2><p>当准备好镜像之后，镜像是死的，需要通过 docker run 命令来启动一个容器，这两者关系有些类似于编程语言中的类和实例</p><p>而 run 命令启动一个容器时，是可以携带各种各样的参数，比如设置端口映射，设置网络、设计磁盘映射等等</p><p>当这些配置项过于复杂时，维护就会很麻烦，所以，为了提高效率，衍生出了 docker-compose</p><p>而 docker-compose.yml 则是用来维护 run 启动个容器时，所需要的各种各样配置参数、环境等</p><p>这样一来，就不用每次启动容器时，自己输入一堆配置参数了，把这些都维护在 docker-compose.yml 文件中，通过 docker-compose 命令来操作，docker-compse 就会自动去启动容器了</p><p>简单的说，docker-compose 就是对 docker 命令进行了一层封装</p><p>本来我们可能需要自己用 docker 命令去拉镜像、创建数据卷、网络、设置环境变量等等，然后再手动启动容器，输入一堆配置参数</p><p>现在有了 docker-compose，就可以把这一系列操作维护在 docker-compose.yml 文件中，一句 docker-compose 命令就可以让 docker-compose 为我们将这些工作全部处理掉，方便、高效</p><p>docker-compose.yml 里的每一项配置语法都对应着 docker 的某个命令、某个参数，只要对 docker 命令熟悉，掌握 docker-compose.yml 是很快的</p><ul><li>Dockerfile 和 docker-compose.yml 区别</li></ul><p>注意，Dockerfile 是用来构建镜像，经过 build 之后，得到的只是一个死的镜像</p><p>docker-compose.yml 则是用来管理容器，经过 up 之后，得到的是一些正在运行中的容器</p><p>两者针对的对象和场景都不一样，但后者可以依赖前者，两个一起使用，来构建 docker 容器，会特别方便</p><h2 id="使用-docker-好处" tabindex="-1"><a class="header-anchor" href="#使用-docker-好处" aria-hidden="true">#</a> 使用 docker 好处</h2><p>docker 上通过容器运行的各种各样的服务，除了有类似于虚拟机一样各自互不影响又可以通信交互的优点外</p><p>我个人觉得，最大的好处在于迁移部署</p><p>有句话这么说来着：一次配置，到处部署</p><p>我现在个人云服务器上就通过 docker 跑着四五个服务：个人博客站、gitbook 站、jenkins、nginx、个人云网盘</p><p>如果我想换台服务器搭建这些服务，那我只需拷贝几份配置文件，在目标机上搭好 docker 环境后，一句 docker 命令就搞定</p><p>再也不用一个个环境的去配置，去下载了</p>',45);function _(u,f){const r=d("ExternalLinkIcon");return n(),s("div",null,[k,i,e("ul",null,[e("li",null,[e("a",l,[o("官方文档"),c(r)])]),e("li",null,[e("a",h,[o("Docker - 从入门到实践"),c(r)])])]),m])}const x=p(t,[["render",_],["__file","介绍.html.vue"]]);export{x as default};
