import{_ as l,o as i,c as e,d as p}from"./app-Zf-yBXw2.js";const s={},c=p('<h1 id="讲讲性能优化" tabindex="-1"><a class="header-anchor" href="#讲讲性能优化" aria-hidden="true">#</a> 讲讲性能优化</h1><p>项目里的性能优化按做法我个人觉得是可以分成两种，一种是一次性优化处理，另一种是持续性优化</p><p>意思是说，有些方面的优化，之前一直没处理，所以确实存在待优化问题，但经过优化处理之后，基本上后续的迭代中就不用太花心思在这方面的优化了，因为优化效果已经有了而且一直存在</p><p>这些场景比如说，针对首屏加载时长的优化</p><p>尤其是单页应用的网站，如果不注意的话，首页下载的资源可能会很多，导致用户等待过长，体验不好</p><p>那针对这个场景，可以进行优化的一些思路就是：</p><ul><li><p>下载的东西尽量少</p><ul><li>一种方向就是懒加载，不需要的没必要首屏就去下载，具体做法就是利用打包工具的分割代码</li></ul></li><li><p>下载的速度快一些</p><ul><li>利用缓存，cdn 缓存，或者浏览器的缓存机制，不常变更的文件可以设置成强缓存</li><li>并行下载，多域名存放资源，因为每个域名限制最多 6 条请求并行</li><li>压缩传输，比如开启 gzip</li><li>资源最好与后端分开存放，这样可以避免下载资源自带携带 cookie</li><li>css 放头部，script 放尾部，因为 script 的下载会阻塞 html 解析，css 下载会阻塞 js 运行</li><li>借助新特性，比如 http2 自带的头部压缩、并行下载的特点</li><li>service worder 的离线缓存</li></ul></li><li><p>首屏由服务端渲染</p></li></ul><p>以上这些优化，通常都是处理过之后就可以了</p><p>那还有一些优化是需要持续优化的，这些场景一般都是因为编写的代码不规范、或者有问题，导致了一些页面性能问题，所以需要在每个迭代的代码编写过程中持续注意的</p><p>比如说：</p><ul><li>资源没及时释放，导致内存泄漏，严重点导致内存溢出 <ul><li>常见的是定时器、延时器的使用，和网络请求的回调监听</li></ul></li><li>css 选择器嵌套太深 <ul><li>通常是因为使用了 sass 之类的预处理器而疏忽了这点</li></ul></li><li>频繁更新 DOM <ul><li>框架使用不当，列表该加 key 值就加，该防抖处理就防抖，节流处理就节流</li></ul></li></ul><p>这些场景的性能优化都是需要有良好的编程习惯，才能避免写出问题比较多的代码，总之就是一种经验吧，不断积累</p>',12),t=[c];function r(_,a){return i(),e("div",null,t)}const u=l(s,[["render",r],["__file","讲讲性能优化.html.vue"]]);export{u as default};
