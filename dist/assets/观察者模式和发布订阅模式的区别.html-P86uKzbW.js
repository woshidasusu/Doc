import{_ as r,r as a,o as _,c as s,a as e,b as t,e as n,d as c}from"./app-PjuKeMiB.js";const p={},i={id:"题目-观察者模式-vs-发布-订阅模式",tabindex:"-1"},l=e("a",{class:"header-anchor",href:"#题目-观察者模式-vs-发布-订阅模式","aria-hidden":"true"},"#",-1),d={href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/25",target:"_blank",rel:"noopener noreferrer"},h=c('<p>刚开始看到这题目，有点懵：观察者模式不就发布-订阅模式吗？不就是说法不同而已吗？</p><p>emmm，如果你也这么认为，那你也可以看看这题。</p><blockquote><p>观察者模式没中间商赚差价 发布订阅模式 有中间商赚差价</p></blockquote><p>网上有人的回答，我觉得特有印象，虽然从广义上来讲，两种模式都是某个状态发生变化的时候，对外通知出去，也就是他们两要干的事，其实是一样的。</p><p>但从实现上来讲：</p><ul><li>观察者模式</li></ul><p>观察者模式是观察者和被观察者两者间的直接交互，比较耦合；</p><p>什么意思，也就是说，观察者对象必须持有被观察者的引用，并手动调用它的方法将自身传递过去，然后被观察者内部需要将这些观察者的引用保存起来，这样就造成了双向关联了，强耦合。</p><p>当被观察者某个状态发生变化时，通过它内部保存的这些观察者引用，手动去通知它们；具体表现到代码上就是：观察者对象都需要实现某个接口、被观察者内部直接调用该接口进行通知。</p><p>因为整个过程，就是观察者和被观察者两者的直接交互，所以通俗理解成：没有中间商赚差价</p><ul><li>发布-订阅模式</li></ul><p>发布-订阅模式的实现上，会有一个中间者，它内部有订阅者的列表、并提供注册订阅、发布的操作。发布者只需关心何时调用发布操作即可，不用去关心到底都有哪些订阅者；订阅者也只需要注册它关心的事件即可，无需关心事件由谁产生。</p><p>也就是通过一个中间媒介、发布者和订阅者都只和该中间媒介交互、所以它们两互相不知道对方，也就实现的解耦。所以这种模式可以通俗理解成：有中间商赚差价</p><p>从代码上来看，这个中间媒介通常是个单例模式，对外的接口都是静态方法。</p><h1 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h1>',15),u={href:"https://juejin.im/post/5cd81a20e51d453b4558d858",target:"_blank",rel:"noopener noreferrer"};function f(m,b){const o=a("ExternalLinkIcon");return _(),s("div",null,[e("h1",i,[l,t(" 题目： "),e("a",d,[t("观察者模式 VS 发布-订阅模式"),n(o)])]),h,e("p",null,[e("a",u,[t("观察者模式与发布订阅模式真的不同"),n(o)])])])}const x=r(p,[["render",f],["__file","观察者模式和发布订阅模式的区别.html.vue"]]);export{x as default};
