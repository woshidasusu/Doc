import{_ as o,r as l,o as s,c as r,a as e,b as n,e as t,d as a}from"./app-xJrSpaa5.js";const d={},c=e("h1",{id:"讲讲-http-报文中常见的头部字段含义",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#讲讲-http-报文中常见的头部字段含义","aria-hidden":"true"},"#"),n(" 讲讲 http 报文中常见的头部字段含义")],-1),p={href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP",target:"_blank",rel:"noopener noreferrer"},u=a(`<p>http 报文的常见头部字段，其实也就是请求头或响应头中的 header 字段</p><p>有些字段是两者都可以用，有些只能各自使用，不同 header 字段都有不同的用途，意义，这里大概来讲讲</p><h3 id="同源跨域相关" tabindex="-1"><a class="header-anchor" href="#同源跨域相关" aria-hidden="true">#</a> 同源跨域相关</h3><p>CORS：Cross-Origin Resource Sharing 跨域资源共享</p><p>浏览器基于安全考虑，默认会对以下请求进行同源限制：</p><ul><li>XMLHttpRequest 请求和 fetch 请求</li><li>Web 字体（CSS 中通过 @font-face 使用跨域字体资源）</li><li>WebGL，canvas 绘制 images/video</li></ul><p>同源限制是指，请求的资源与文档的路径必须是同协议，同域名，同端口时，才会被允许，否则浏览器会进行拦截。</p><p>但某些场景下，不想要同源限制，那么就可以利用跨域资源共享（CORS）解决方案来处理，涉及到的相关 header 字段有：</p><ul><li><strong>Access-Control-Allow-Origin</strong> &amp; <strong>Origin</strong></li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 响应头
Access-Control-Allow-Origin: &lt;origin&gt; | *

// 请求头
Origin: &lt;origin&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前者是响应头中的字段，取值可以是 <code>*</code> 表明允许所有外域访问该资源，也可以是某个指定的域名，表明只有该外域可以访问</p><p>后者是请求头中的字段，表明源站 URI</p><ul><li><strong>Access-Control-Allow-Methods</strong> &amp; <strong>Access-Control-Request-Methods</strong></li></ul><p>前者是响应头中的字段，后者是请求头中的字段，用于在预检请求中，客户端和服务端协商跨域支持的方法的交互</p><ul><li><strong>Access-Control-Allow-Headers</strong> &amp; <strong>Access-Control-Request-Headers</strong></li></ul><p>前者是响应头中的字段，后者是请求头中的字段，用于在预检请求中，客户端和服务端协商跨域支持的 header 的交互</p><ul><li><strong>Access-Control-Expose-Headers</strong></li></ul><p>在跨域请求中，客户端只能拿到一些基本的响应头，比如 Cache-Control，Content-Length，Content-Type，Last-Modified 之类，如果需要访问其他 header，则需要服务器设置该 header</p><ul><li><strong>Access-Control-Max-Age</strong></li></ul><p>这是响应头中的字段，表明预检请求的有效期，在有效期内无法再进行预检请求</p><p>预检指的是，在真正的请求发送之前，先发送一条带有 Access-Control-Request-xxx 的请求给服务端，询问支持的跨域请求的方法、头部字段、身份认证等</p><h3 id="缓存相关" tabindex="-1"><a class="header-anchor" href="#缓存相关" aria-hidden="true">#</a> 缓存相关</h3>`,22),g={href:"https://github.com/woshidasusu/Doc/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.md",target:"_blank",rel:"noopener noreferrer"},h=a(`<ul><li><strong>Cache-Control</strong></li></ul><p>禁止进行缓存</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Cache-Control: no-store
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>强制确认缓存，请求头中会携带一些给服务端验证的字段，如 If-Modified-Since 或 If-None-Match</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Cache-Control: no-cache
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>私有缓存和公共缓存，私有指只有浏览器本身可以缓存，中间代理或 CDN 不允许缓存，公共则是都允许缓存</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Cache-Control: private
Cache-Control: public
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>缓存过期机制</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Cache-Control: max-age=31536000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><strong>Expires</strong></li></ul><p>响应头中的字段，服务端返回告知浏览器资源的过期时间，是一个绝对时间，基于客户端机子上的时间，http 1.0 中的字段</p><ul><li><strong>Last-Modified</strong> &amp; <strong>If-Modified-Since</strong></li></ul><p>前者是响应头中的字段，告知浏览器资源上次修改时间，结合 max-age 一起使用来判断缓存是否过期</p><p>后者是请求头中的字段，用于将前者的值发给服务端验证</p><ul><li><strong>ETag</strong> &amp; <strong>If-None-Match</strong></li></ul><p>前者是响应头中的字段，是基于资源内容计算出的 hash 值，表明文件是否有变动过，用来弥补 Last-Modified 的缺陷</p><p>后者是请求头中的字段，用于将前者告知服务端验证</p><h3 id="内容协商相关" tabindex="-1"><a class="header-anchor" href="#内容协商相关" aria-hidden="true">#</a> 内容协商相关</h3><p>因为请求的资源可以是各种类型、各种编码、各种语言的，所以这过程会有一个协商，涉及的相关 header：</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code>GET / HTTP/1.1
Host: gitbook.dasu.fun
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code>HTTP/1.1 200 OK
Server: nginx/1.17.5
Date: Fri, 03 Jan 2020 02:56:54 GMT
Last-Modified: Thu, 02 Jan 2020 16:05:14 GMT
Cache-Control: no-cache
Pragma: no-cache
Expires: 0
Content-Type: text/html; charset=utf-8
Content-Length: 18196
ETag: &quot;5e0e14ba-4714&quot;
Accept-Ranges: bytes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>Accept, Accept-Charset</strong> &amp; <strong>Content-Type</strong></li></ul><p>前者是请求头中的字段，表明浏览器支持的资源类型，多个值用 <code>,</code> 隔开和编码类型</p><p>后者是响应头中的字段，表明资源的类型以及编码，以 <code>;</code> 隔开</p><ul><li><strong>Accept-Encoding</strong> &amp; <strong>Content-Encoding</strong></li></ul><p>前者是请求头中的字段，表明浏览器支持的解压缩算法，多个值用 <code>,</code> 隔开</p><p>后者是响应头中的字段，表明资源的压缩算法</p><ul><li><strong>Accept-Language</strong> &amp; <strong>Content-Language</strong></li></ul><p>前者是请求头中的字段，表明浏览器想要的语言</p><p>后者是响应头中的字段，表明资源的的语言</p><h3 id="cookie-相关" tabindex="-1"><a class="header-anchor" href="#cookie-相关" aria-hidden="true">#</a> Cookie 相关</h3><p>Cookie 是服务器发送到浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器请求时，自动被携带发送给服务器</p><p>通常可用来告知服务器，两个请求是否来自同一浏览器，如保持用户的登录状态</p><p>Cookie 主要用于以下三方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数、或其他需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p>涉及的相关 header 有：</p><h4 id="set-cookie-cookie" tabindex="-1"><a class="header-anchor" href="#set-cookie-cookie" aria-hidden="true">#</a> <strong>Set-Cookie</strong> &amp; <strong>Cookie</strong></h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Set-Cookie: &lt;cookie名&gt;=&lt;cookie值&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>前者是响应头中的字段，浏览器在看到这样的 header 时，会自动往 Cookie 里写入，再下次请求时，自动携带在 Cookie 字段发送给服务端</p><p>对于用户甚至前端开发者来说，Cookie 都可以说是有一定的透明性的</p><p>不过也可以手动通过 Document.cookie 来操作 Cookie</p><ul><li>Cookie 的有效期、Secure、HttpOnly 标记</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以给 Cookie 设置多个属性，比如有效期等，以 <code>;</code> 隔开</p><p>有效期可以通过设置 <code>Expires=xxx</code> 或者 <code>Max-Age=xxx</code>，前者是过期时间，是一个绝对时间，后者是有效期，相对时间</p><p>加了 Secure 标记的 Cookie 只会被 HTTPS 协议请求发送给服务端</p><p>加了 HttpOnly 标记的 Cookie 可以禁止 js 通过 Document.cookie 来访问</p><ul><li>Cookie 作用域</li></ul><p>Cookie 作用域由 Domain 和 Path 两者决定</p><p>子域名可以访问父域名的 Cookie，但发过来则不行</p><ul><li>SameSite Cookies</li></ul><p>这类 Cookie 可以指定在跨站请求时不会被发送，从而可以阻止跨站请求伪造工具（CSRF）</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Set-Cookie: key=value; SameSite=Strict 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="分段下载相关" tabindex="-1"><a class="header-anchor" href="#分段下载相关" aria-hidden="true">#</a> 分段下载相关</h3><ul><li><p><strong>Accept-Range</strong>：这是响应头中的字段，表明服务端是否支持分段请求，none 时表明不支持</p></li><li><p><strong>Range</strong>：这是请求头中的字段，表明客户端需要像要下载的片段范围</p></li><li><p><strong>If-Range</strong>：这是请求头中的字段，用于给 Range 生效设置条件，通常是 ETag 的值</p></li><li><p><strong>Content-Range</strong>：这是响应头中的字段，表明返回的资源片段范围</p></li><li><p><strong>Content-Length</strong>：这是响应头中的字段，表明返回资源片段的大小</p></li></ul><p>当分段下载时，返回码为 206，当超出资源范围时，返回 416</p><h3 id="重定向相关" tabindex="-1"><a class="header-anchor" href="#重定向相关" aria-hidden="true">#</a> 重定向相关</h3><p>重定向是浏览器重新向新 URL 发请求的行为，对于用户来说，可以说是透明的</p><p>涉及的请求头就是响应头中的 <strong>Location</strong> 字段，但有这么三类：</p><ul><li>永久性重定向</li></ul><p>永久性重定向，指的是后续请求直接都往新地址发送，不会再往旧地址发送</p><p>301：非 GET 方法有可能会变成 GET 方法请求</p><p>308：方法和消息主体都不会发送变化</p><ul><li>临时性重定向</li></ul><p>临时性重定向，后续请求仍旧会往旧地址发送</p><p>302：非 GET 方法可能会变更为 GET 方法</p><p>307：方法和消息主体都不会发生变化</p><p>303：非 GET 方法都会变成 GET 方法请求，且丢失消息主体，可用来防止表单页的重复触发</p><ul><li>特殊性重定向</li></ul><p>304：告知浏览器可直接使用本地缓存</p><p>300：重定向链接有多个，给用户手工选择</p><ul><li>其他重定向方式</li></ul><p>js 重定向：通过 window.location</p><p>html 的 meta：通过 <code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;URL=http://xxx&quot; /&gt;</code></p><p>优先级的话，http 协议重定向 &gt; HTML &gt; js</p>`,75);function v(m,x){const i=l("ExternalLinkIcon");return s(),r("div",null,[c,e("blockquote",null,[e("p",null,[n("本文参考: "),e("a",p,[n("MDN/HTTP"),t(i)])])]),u,e("p",null,[e("a",g,[n("讲讲强缓存和协商缓存，F5 和 Ctrl + F5 的区别"),t(i)])]),h])}const C=o(d,[["render",v],["__file","讲讲常见的报文头部字段含义.html.vue"]]);export{C as default};
