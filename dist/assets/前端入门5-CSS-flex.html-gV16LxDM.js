import{_ as t,r as l,o as s,c as d,a as e,b as i,e as n,d as r}from"./app-Zf-yBXw2.js";const o={},c=e("h1",{id:"声明",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#声明","aria-hidden":"true"},"#"),i(" 声明")],-1),p=e("p",null,"本系列文章内容全部梳理自以下四个来源：",-1),u=e("li",null,"《HTML5权威指南》",-1),m=e("li",null,"《JavaScript权威指南》",-1),g={href:"https://developer.mozilla.org/zh-CN/docs/Web",target:"_blank",rel:"noopener noreferrer"},v={href:"https://github.com/smyhvae/Web",target:"_blank",rel:"noopener noreferrer"},h=r(`<p>作为一个前端小白，入门跟着这四个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p><h1 id="正文-弹性布局flex" tabindex="-1"><a class="header-anchor" href="#正文-弹性布局flex" aria-hidden="true">#</a> 正文-弹性布局flex</h1><p>弹性布局的作用有点儿类似 Android 中 LinearLayout 和 RelativeLayout 两者的合成版，即：支持横向布局，纵向布局，start，end，center 布局，宽高按比例瓜分等等，当然它还有很多其他功能，比如自动换行，按指定 order 排列等。总之有了 Android 基础，理解弹性布局 flex 蛮容易的。</p><p>可以这么的理解，传统的网页布局方式是通过 display 和 position 以及 float 三者完成的，借助块级元素，行内元素特性，结合 position 指定的相对布局、绝对布局、固定布局方式来实现各种排版效果。如果需要浮动，则借助 float。</p><p>但这种传统的方式，一来使用较复杂，二来某些排版效果不好实现，如列表、居中、响应式布局等效果。</p><p>而 flex 则能够很好的完成传统的布局工作，而且，它还可以支持响应式布局。</p><h3 id="_1-基础概念" tabindex="-1"><a class="header-anchor" href="#_1-基础概念" aria-hidden="true">#</a> 1.基础概念</h3><h4 id="两根轴线" tabindex="-1"><a class="header-anchor" href="#两根轴线" aria-hidden="true">#</a> 两根轴线</h4><p>当使用 flex 布局时，首先想到的是两根轴线：主轴和交叉轴。主轴由 flex-direction 定义，另一根轴垂直于它。我们使用 flexbox 的所有属性都跟这两根轴线有关, 所以有必要在一开始首先理解它。</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-08cdf2e794ab15ac.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="flex"></p><p>理解主轴和交叉轴的概念对于对齐 flexbox 里面的元素是很重要的；因为 flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。</p><h4 id="布局空白" tabindex="-1"><a class="header-anchor" href="#布局空白" aria-hidden="true">#</a> 布局空白</h4><p>布局空白：available space，大概来说，flex 容器大小扣掉 items 的 flex-basis 指定的占据的空间大小之外剩余的区域，flex-basis 通常是指 item 本身的大小，当然也可以手动设置。</p><p>flex 的一些属性就是通过改变 flex 容器中的布局空白分配来达到对齐等效果的。</p><p>比如 items 的 flex-grow 拉伸或者 flex 容器的 justify-content 主轴对齐等，其实就是将这些布局空白按照不同算法分配给各个 item，分给 item 时，是要直接填充进 item 的内容里达到拉伸效果，还是就简单的将空白围绕在 item 周围达到类似 margin 效果来实现 item 的居中、靠左、靠右、均分等对齐方式。</p><p>具体属性不了解没关系，下面的章节会讲，知道概念即可。</p><h3 id="_2-flex相关属性" tabindex="-1"><a class="header-anchor" href="#_2-flex相关属性" aria-hidden="true">#</a> 2.flex相关属性</h3><p>对任意块级元素标签设置 display: flex 即可让这个元素作为 flex 容器存在，也就可以使用 flex 的相关属性了。</p><p>flex 的属性并不多，目前只有 13 个，其中有 7 个是 flex 弹性盒子容器本身所使用的属性，6 个是 flex-item 弹性盒子的子项使用的属性。其中，有些属性只是将其他属性的集中简化使用，因此，真正具有布局用途的属性并不多，很好掌握。</p><p>作用于 flex 弹性盒子容器身上的属性：</p><h4 id="flex-direction" tabindex="-1"><a class="header-anchor" href="#flex-direction" aria-hidden="true">#</a> flex-direction</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>flex-direction: row(default) | row-reverse | column | column-reverse
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用于设置主轴的方向，flex 分主轴和交叉轴两个概念，items 布局时，默认延主轴方向进行，因此通过设置主轴是水平方向还是垂直方向就可以实现 items 的水平或垂直布局。</p><ul><li>row：默认值，设置主轴为水平方向</li><li>column：设置主轴为垂直方向</li></ul><p>其他属性就不介绍了，因为主轴方向就两个，要么水平，要么垂直，其他的区别仅在于水平时是从左到右，还是从右到左，所以这个属性的影响因素之一的 LTR 和 RTL，但没必要考虑这么多，这些场景应该不多，知道这个是用来设置主轴方向就够了，我觉得。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-fc89a44d228d398d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="flex-direction"></p><h4 id="flex-wrap" tabindex="-1"><a class="header-anchor" href="#flex-wrap" aria-hidden="true">#</a> flex-wrap</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>flex-wrap: nowrap(default) | wrap | wrap-reverse
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用于设置是否允许换行，默认值 nowrap。</p><p>当设置了 wrap 时，允许 items 在主轴方向溢出时自动进行换行布局，这点可以很好的用来实现响应式布局，比如当空间逐渐缩小时，原本水平排列的控件换成垂直方向排版。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-9a74643008a31410.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="flex-wrap"></p><h4 id="flex-flow" tabindex="-1"><a class="header-anchor" href="#flex-flow" aria-hidden="true">#</a> flex-flow</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>flex-flow: &lt;&#39;flex-direction&#39;&gt; || &lt;&#39;flex-wrap&#39;&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个属性并没有另外的含义，它只是 flex-direction 和 flex-wrap 的简写用法而已。</p><p>如果你不想单独使用上述两个属性，可以将它们一起在 flex-flow 使用，如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>flex-flow: row wrap
//等效于
flex-direction: row;
flex-wrap: wrap;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="justify-content" tabindex="-1"><a class="header-anchor" href="#justify-content" aria-hidden="true">#</a> justify-content</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>justify-content: normal(default) | &lt;content-distribution&gt; | &lt;overflow-position&gt;? [ &lt;content-position&gt; | left | right ]
where 
&lt;content-distribution&gt; = space-between | space-around | space-evenly | stretch
&lt;overflow-position&gt; = unsafe | safe
&lt;content-position&gt; = center | start | end | flex-start | flex-end
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用于设置 items 在主轴方向上的对齐方式，可以靠左，靠右，居中或者按比例均分等效果。</p><p>需要先明确一点概念，对齐是指 items 在 flex 容器中的排版对齐方式，那么要想 flex 容器可以控制 items 的对齐方式，那主轴方向上自然就还需要有布局空白，如果都没有布局空白了，不就表明 items 已充满 flex 容器了，那谈何对齐。</p><p>那么，如果存在至少一个 item，它的 flex-grow 属性不等于 0，justify-content 这个属性就失效了，因为 flex-grow 表示允许 item 按照比例瓜分布局空白，这样一来布局空白被瓜分完了，flex 容器在主轴方向上已被 items 充满， 也就没有对齐一说了。</p><p>所以要能够正确的使用该属性来控制 items 在主轴方向的对齐方式，那么就需要注意 item 中会影响布局空白的属性，如 flex-grow，flex-basis 这些的使用。</p><p>下面看看各属性值介绍（下面的介绍不考虑 RTL 的情况，默认都以 LTR 为主）：</p><ul><li>start：主轴是水平方向的话，左对齐方式排版；主轴是垂直方向的话，上对齐方式排版；</li><li>end：主轴是水平方向的话，右对齐方式排版；主轴是垂直方向的话，下对齐方式排版；</li><li>center：居中方式排版；</li><li>space-between：等比例瓜分布局空白，每行首元素对齐，末元素对齐，每行各元素间距一致；</li><li>space-around：与上述的类似效果，区别仅在于，每行首元素并不是在 flex 容器内容区域左边就开始布局，它距离 flex 容器左边的距离等于各个元素之间间距的一半。说白点，就是行首元素和末尾元素的周边有类型 margin 值存在。</li></ul><p>剩余的属性值不介绍了，因为我也还没有搞懂它们的含义和应用场景。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-196cce807ce5f660.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="justify-content"></p><p>(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )</p><h4 id="align-items" tabindex="-1"><a class="header-anchor" href="#align-items" aria-hidden="true">#</a> align-items</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>align-items: normal | stretch | &lt;baseline-position&gt; | [ &lt;overflow-position&gt;? &lt;self-position&gt; ]
where 
&lt;baseline-position&gt; = [ first | last ]? baseline
&lt;overflow-position&gt; = unsafe | safe
&lt;self-position&gt; = center | start | end | self-start | self-end | flex-start | flex-end
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用于控制 items 在交叉轴方向上的排版布局方式，justify-content 是能控制主轴上的排版，而这个属性则是用于控制交叉轴，通常两个都会一起使用，相互结合，可以达到一些类似页面居中效果。</p><p>看看属性值：</p><ul><li>flex-start：交叉轴方向，从起点开始布局排版</li><li>flex-end：交叉轴方向，从末尾开始布局排版</li><li>center：交叉轴方向，从中间开始布局排版</li><li>stretch：交叉轴方向，如果 items 在交叉轴方向没有设置大小，那么让 items 在交叉轴的方向充满 flex 容器的高度。</li></ul><p>其他属性不介绍了，不熟悉。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-6ce0c20a2721cd63.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="align-items"></p><p>(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )</p><p>stretch 要能够生效，需要在 items 在交叉轴方向的不设置大小，如上图中主轴是水平方向，那么 items 需要不设置 height，此时 stretch 才能够让 items 拉伸占据交叉轴的高度。</p><p>有一点需要注意，当 flex 容器的 items 在主轴方向上只有一行时，可以很明确的使用这个属性来控制在交叉轴的排版方式。但，如果 items 在主轴上超过一行，那么最终的效果可能就不是想要的了，比如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-bac610aee3b3dddc.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="align-items2"></p><p>如果是想实现多行的 items 都作为一个整体居中，那么用 align-items 就无法实现了，针对这种有多行的情况，需要用另外一个属性来控制：align-content。</p><h4 id="align-content" tabindex="-1"><a class="header-anchor" href="#align-content" aria-hidden="true">#</a> align-content</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>align-content: normal | &lt;baseline-position&gt; | &lt;content-distribution&gt; | &lt;overflow-position&gt;? &lt;content-position&gt;
where 
&lt;baseline-position&gt; = [ first | last ]? baseline
&lt;content-distribution&gt; = space-between | space-around | space-evenly | stretch
&lt;overflow-position&gt; = unsafe | safe
&lt;content-position&gt; = center | start | end | flex-start | flex-end
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 flex 容器的 items 设置了溢出换行属性，且当前在交叉轴方向上存在多行 item 的情况下，该属性才会生效。</p><p>网上有种翻译，说这个属性是用于轴对齐，我不是很理解，我自己粗俗的分两种情况理解：</p><p>当需要进行 start, center, end 这些排版时，是将这些多行的 items 都看成一个整体，然后进行交叉轴方向上的排版控制。此时，将多行 item 看成一行之后，那么这个 align-content 之后的排版布局就跟 align-items 一样的效果了。</p><p>其他的 space-around，space-between 究竟是如何计算排版的，不熟悉。</p><p>属性值含义不看了，跟 align-items 一样的效果，直接看示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-a4b4b11bb9799c85.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="align-content"></p><p>(ps：flex 容器设置了 padding，所以 start 和 end 才没有贴靠边界 )</p><h4 id="place-content" tabindex="-1"><a class="header-anchor" href="#place-content" aria-hidden="true">#</a> place-content</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>place-content: &lt;&#39;align-content&#39;&gt; &lt;&#39;justify-content&#39;&gt;?
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个属性并没有另外的含义，它只是 align-content 和 justify-content 的简写用法而已。</p><p>如果你不想单独使用上述两个属性，可以将它们一起在 place-content 使用，如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>place-content: center center
//等效于
align-content: center;
justify-content: center;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作用于 flex-item 弹性盒子的子项身上的属性：</p><h4 id="flex-basis" tabindex="-1"><a class="header-anchor" href="#flex-basis" aria-hidden="true">#</a> flex-basis</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>flex-basis: content | &lt;&#39;width&#39;&gt;

where 
&lt;&#39;width&#39;&gt; = [ &lt;length&gt; | &lt;percentage&gt; ] &amp;&amp; [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用于设置 items 在主轴方向的大小，如果主轴是水平方向，相当于设置 width，此时，该属性值会覆盖掉 width 设置的大小。</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-abb7feeb207f305d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="ps"></p><p>尝试了下，在 chorme 浏览器上 content 属性不生效，不清楚，可能不同浏览器行为还不一样，既然这样，就先暂时不深入了解这个属性了，大概知道用于设置主轴方向上的 item 大小即可。</p><p>就算要使用，先直接用指定数值大小的方式好了。</p><h4 id="flex-grow" tabindex="-1"><a class="header-anchor" href="#flex-grow" aria-hidden="true">#</a> flex-grow</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>flex-grow: &lt;number&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用于设置 item 在主轴方向上的拉伸因子，即如果 flex 容器还有剩余空间，会按照各 item 设置的拉伸因子比例关系分配。默认值为 0，即不拉伸。</p><p>作用很像 Andorid 中的 LinearLayout 的 child 里设置了 layout_weight 用途一样。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-28701dfa2bfefc3d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="flex-grow"></p><h4 id="flex-shrink" tabindex="-1"><a class="header-anchor" href="#flex-shrink" aria-hidden="true">#</a> flex-shrink</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>flex-shrink: &lt;number&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用于设置 item 在主轴方向上的收缩因子，跟 flex-grow 刚好反着来。当 flex 容器空间不够，item 要溢出时，设置次属性可控制 item 按比例进行相应收缩，以便不让 item 溢出，默认 1，值越大收缩倍数越大，最后 item 就越小，0 表示不收缩，负值无效。</p><p>另外，如果设置了换行属性，那么这个就无效了。换行和收缩都是用于解决 item 在主轴方向上溢出的问题，既然是互斥，且换行优先级高，那么设置了换行，就不会再对 item 进行收缩了。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-456ce486db29b432.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="flex-shrink"></p><h4 id="flex" tabindex="-1"><a class="header-anchor" href="#flex" aria-hidden="true">#</a> flex</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>flex: none | auto | initial | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这属性是 flex-grow，flex-shrink，flex-basis 三个属性的简化使用，有三种属性值：</p><ul><li>none：元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应flex容器。相当于将属性设置为 <code>flex: 0 0 auto</code>。</li><li>auto：元素会根据自身的宽度与高度来确定尺寸，但是会自行伸长以吸收flex容器中额外的自由空间，也会缩短至自身最小尺寸以适应容器。这相当于将属性设置为 <code>flex: 1 1 auto</code>.</li><li>initial：属性默认值， 元素会根据自身宽高设置尺寸。它会缩短自身以适应容器，但不会伸长并吸收flex容器中的额外自由空间来适应容器 。相当于将属性设置为&quot;<code>flex: 0 1 auto</code>&quot;。</li></ul><p>flex 属性可以指定 1 个，2 个或 3 个值。</p><p><strong>单值语法</strong>: 值必须为以下其中之一:</p><ul><li>一个无单位<strong>数(&lt;number&gt;)</strong>: 它会被当作 <code>&lt;flex-grow&gt;的值。</code></li><li>一个有效的**宽度(width)**值: 它会被当作 <code>&lt;flex-basis&gt;的值。</code></li><li>关键字 <code>none, auto</code>,或<code>initial</code>.</li></ul><p><strong>双值语法</strong>: 第一个值必须为一个无单位数，并且它会被当作<code>&lt;flex-grow&gt;的值。第二个值必须为以下之一：</code></p><ul><li>一个无单位数：它会被当作<code>&lt;flex-shrink&gt;的值。</code></li><li>一个有效的宽度值: 它会被当作<code>&lt;flex-basis&gt;的值。</code></li></ul><p><strong>三值语法:</strong></p><ul><li>第一个值必须为一个无单位数，并且它会被当作<code>&lt;flex-grow&gt;的值。</code></li><li>第二个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-shrink&gt;的值。</code></li><li>第三个值必须为一个有效的宽度值， 并且它会被当作<code>&lt;flex-basis&gt;的值。</code></li></ul><h4 id="align-self" tabindex="-1"><a class="header-anchor" href="#align-self" aria-hidden="true">#</a> align-self</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>align-self: auto | normal | stretch | &lt;baseline-position&gt; | &lt;overflow-position&gt;? &lt;self-position&gt;
where 
&lt;baseline-position&gt; = [ first | last ]? baseline
&lt;overflow-position&gt; = unsafe | safe
&lt;self-position&gt; = center | start | end | self-start | self-end | flex-start | flex-end
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用于给单个 item 设置交叉轴方向上的排版布局方式，属性值和作用跟 align-items 一样，区别仅在于 align-items 是 flex 容器的属性，它会作用于所有的 items 上；而 align-self 允许对单个 item 设置，该值会覆盖 align-items 设置的属性值。</p><p>这样就可以实现控制交叉轴上的每个 item 的不同布局方式，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-5ee64d58ee132497.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="align-items"></p><h4 id="order" tabindex="-1"><a class="header-anchor" href="#order" aria-hidden="true">#</a> order</h4><p>语法格式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>order: &lt;integer&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用于控制 items 的排版顺序，item 将按照 order 属性值的增序进行布局。拥有相同 order 属性值的元素按照它们在源代码中出现的顺序进行布局。默认值为 0，可设置负值，排序将在默认不设置的 item 前面。</p><p>示例：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-326dd86eb0d1ee85.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="order"></p><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h4><p>我觉得，这些属性大体记得每个属性的主要用途即可，至于每个属性值如何设置，如何相互结合使用可以达到什么样的效果，写代码的时候再调就是了。</p><h3 id="_3-应用场景" tabindex="-1"><a class="header-anchor" href="#_3-应用场景" aria-hidden="true">#</a> 3.应用场景</h3><p>以下场景中，如没有特别指明，flex 容器基本样式和 item 基本样式如下：</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code>.flex
{
    width: 200px;
    height: 200px;
    border-radius: 20px;
    background-color: #FFFFFF;
}

.dot {
    width: 50px;
    font-size: 28px;
    line-height: 50px;
    text-align: center;
    color: #FFFFFF;
    height: 50px;
    border-radius: 25px;
    background-color: black;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>长这个样子：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-9f2db5850a9a9d61.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="基本样式"></p><p>白色区域是 flex 容器，黑色圆圈是 item。</p><h4 id="场景1" tabindex="-1"><a class="header-anchor" href="#场景1" aria-hidden="true">#</a> 场景1:</h4><p>在页面中把一个元素居中：item 水平、垂直方向都居中</p><div class="language-css line-numbers-mode" data-ext="css"><pre class="language-css"><code>.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
    justify-content: center;/*水平居中*/
    align-items: center;/*垂直居中*/
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://upload-images.jianshu.io/upload_images/1924341-a51d6aced1b8644f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="场景1"></p><h4 id="场景2" tabindex="-1"><a class="header-anchor" href="#场景2" aria-hidden="true">#</a> 场景2：</h4><p>前后有固定大小 item，中间区域自动拉伸占据可用空间。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code>&lt;style &gt;
.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
}
&lt;/style&gt;

&lt;div class=&quot;flex&quot;&gt;
    &lt;div class=&quot;dot&quot; &gt;1&lt;/div&gt;
    &lt;div class=&quot;dot&quot; style=&quot;flex-grow: 1&quot;&gt;2&lt;/div&gt;
    &lt;div class=&quot;dot&quot; &gt;3&lt;/div&gt;
&lt;/div&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://upload-images.jianshu.io/upload_images/1924341-bbf735fb6e50cfbb.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="场景2"></p><h4 id="场景3" tabindex="-1"><a class="header-anchor" href="#场景3" aria-hidden="true">#</a> 场景3：</h4><p>响应式布局，在屏幕尺寸允许的情况下呈水平布局，但是在屏幕不允许的情况下可以水平折叠。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
    flex-wrap: wrap;/*溢出时换行*/
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://upload-images.jianshu.io/upload_images/1924341-2624d00b8b06428e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="场景3"></p><h4 id="场景4" tabindex="-1"><a class="header-anchor" href="#场景4" aria-hidden="true">#</a> 场景4：</h4><p>水平排列的一组 item 中，前几个左对齐，后几个右对齐。</p><p>这个需要结合块级元素的 margin 属性使用，当设置 margin: auto 时表示，将尽可能占据足够多的空间。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code>&lt;style &gt;
.flex
{
    display: flex;/* 声明这个元素作为 flex 容器 */
    flex-direction: row;/*主轴为水平方向*/
}
&lt;/style&gt;

&lt;div class=&quot;flex&quot;&gt;
    &lt;div class=&quot;dot&quot; &gt;1&lt;/div&gt;
    &lt;div class=&quot;dot&quot; &gt;2&lt;/div&gt;
    &lt;div class=&quot;dot&quot; margin-left=&quot;auto&quot;&gt;3&lt;/div&gt;
&lt;/div&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://upload-images.jianshu.io/upload_images/1924341-43f4d7ec238e1ad8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="场景4"></p>`,155);function x(f,b){const a=l("ExternalLinkIcon");return s(),d("div",null,[c,p,e("ul",null,[u,m,e("li",null,[e("a",g,[i("MDN web docs"),n(a)])]),e("li",null,[e("a",v,[i("Github:smyhvae/web"),n(a)])])]),h])}const _=t(o,[["render",x],["__file","前端入门5-CSS-flex.html.vue"]]);export{_ as default};
