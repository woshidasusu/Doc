import{_ as a,r as t,o as l,c as r,a as e,b as o,e as n,d as s}from"./app-Zf-yBXw2.js";const c={},d=e("h1",{id:"本地存储",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本地存储","aria-hidden":"true"},"#"),o(" 本地存储")],-1),p={href:"https://github.com/ljianshu/Blog/issues/25",target:"_blank",rel:"noopener noreferrer"},h=s('<p>前端浏览器的存储有以下几个技术：</p><ul><li>cookie</li><li>sessionStorage</li><li>localStroage</li><li>indexedDB</li></ul><h3 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie" aria-hidden="true">#</a> cookie</h3><p>cookie 的本职工作并非本地存储，而是弥补 HTTP 协议的无状态，毕竟服务端需要知道前后不同的请求是否有关联等等</p><p>cookie 以键值对存储在浏览器上，存储的数据在每次请求时，都会自动携带到请求头的 cookie 字段中</p><p>使用 cookie 有两种方式：</p><ul><li>服务端返回的响应头中设置 set-cookie 字段，字段值会被浏览器自动存储</li><li>客户端的 js 脚本里，通过 document.cookie 来设置</li></ul><p>每个 cookie 都有几个属性：</p><ul><li><strong>Name</strong>：key 值</li><li><strong>Value</strong>：value 值</li><li><strong>Domain</strong>：所属域，同域或其子域以及结合 Path 属性控制的 cookie 才会被自动添加到请求中</li><li><strong>Path</strong>：所属路径，和 Domain 一起决定 cookie 的作用域</li><li><strong>Expires</strong>：过期时间，绝对时间</li><li><strong>Size</strong>：大小，不能超过 4K</li><li><strong>HttpOnly</strong>：能否被 js 读取</li><li><strong>Secure</strong>：需要 HTTPS 协议才会让 cookie 添加到请求头上</li><li><strong>SameSite</strong>：新特性，跨站请求中不允许 cookie 自动添加到请求头上，预防 CSRF 攻击</li></ul><p>cookie 也有一些缺陷：容易被攻击、不安全、占用网络资源</p><h3 id="sessionstorage" tabindex="-1"><a class="header-anchor" href="#sessionstorage" aria-hidden="true">#</a> sessionStorage</h3><p>会话存储，生命期跟随会话，简单点理解，就是浏览器 tab 页面，当关闭时，就清空，否则在这期间，一直存活</p><p>通常可用来在一些表单页面刷新时，恢复上次表单内容，这种场景，页面关闭就没必要存储这些数据了</p><p>大小同样有限制，好像是 5M 左右，存储时以键值对形式存储</p><p>使用方式：</p><ul><li>通过 window.sessionStorage</li><li>常用方法：<code>setItem(&#39;key&#39;, &#39;value&#39;)</code>， <code>getItem(&#39;key&#39;)</code></li></ul><h3 id="localstorage" tabindex="-1"><a class="header-anchor" href="#localstorage" aria-hidden="true">#</a> localStorage</h3><p>本地存储，浏览器的持久化存储，即使关闭浏览器，数据仍在，除非被清除</p><p>通常可用来存储一些页面主题的用户自定义配置，或者一些固定的资源</p><p>大小也有限制，5M 左右，存储时也是以键值对形式存储</p><p>使用方式：</p><ul><li>通过 window.localStorage</li><li>常用方法：<code>setItem(&#39;key&#39;, &#39;value&#39;)</code>， <code>getItem(&#39;key&#39;)</code></li></ul><h3 id="indexeddb" tabindex="-1"><a class="header-anchor" href="#indexeddb" aria-hidden="true">#</a> indexedDB</h3><p>上面三种存储方式，都只适用于数据量不大、且简单的场景</p><p>当需要存储大量数据，或很复杂的数据时，可使用 indexedDB，它是浏览器上的非关系型数据库</p><p>大小好像没有限制，可以存储字符串、二进制数据等</p><p>支持异步、事物、同源限制，也是键值对存储</p>',27);function g(u,k){const i=t("ExternalLinkIcon");return l(),r("div",null,[d,e("blockquote",null,[e("p",null,[o("本文参考："),e("a",p,[o("浏览器存储"),n(i)])])]),h])}const m=a(c,[["render",g],["__file","本地缓存.html.vue"]]);export{m as default};
