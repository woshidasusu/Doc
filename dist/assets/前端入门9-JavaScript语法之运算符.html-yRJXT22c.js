import{_ as t,r as l,o as d,c as s,a,b as e,e as n,d as u}from"./app-pwInIdNR.js";const r={},o=a("h1",{id:"声明",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#声明","aria-hidden":"true"},"#"),e(" 声明")],-1),p=a("p",null,"本系列文章内容全部梳理自以下几个来源：",-1),c=a("li",null,"《JavaScript权威指南》",-1),v={href:"https://developer.mozilla.org/zh-CN/docs/Web",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/smyhvae/Web",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/goddyZhao/Translation/tree/master/JavaScript",target:"_blank",rel:"noopener noreferrer"},h=u(`<p>作为一个前端小白，入门跟着这几个来源学习，感谢作者的分享，在其基础上，通过自己的理解，梳理出的知识点，或许有遗漏，或许有些理解是错误的，如有发现，欢迎指点下。</p><p>PS：梳理的内容以《JavaScript权威指南》这本书中的内容为主，因此接下去跟 JavaScript 语法相关的系列文章基本只介绍 ES5 标准规范的内容、ES6 等这系列梳理完再单独来讲讲。</p><h1 id="正文-运算符" tabindex="-1"><a class="header-anchor" href="#正文-运算符" aria-hidden="true">#</a> 正文-运算符</h1><p>程序中的代码其实就是利用各种运算符来辅助完成各种指令功能，在 JavaScript 中，有一些不同于 Java 中的运算符处理，这次就来讲讲这些运算符。</p><p>由于我已经有了 Java 的基础了，本节不会讲基础的运算符介绍，比如算术表达式中的加减乘除取余等、关系表达式中的大于小于等、逻辑表示式中的自增、自减、移位等等，这些基础运算符的含义、用法、优先级这些跟 Java 基本没有区别，所以就不介绍了。</p><p>下面着重讲一些在 JavaScript 比较不同的行为的一些运算符：</p><h3 id="运算符" tabindex="-1"><a class="header-anchor" href="#运算符" aria-hidden="true">#</a> &quot;+&quot; 运算符</h3><p>任何数据类型的变量都可以通过 &quot;+&quot; 运算符来进行计算，所以它有一套处理规则，通常要么就是按数字的加法运算处理、要么就是按照字符串的拼接处理，处理规则如下：</p><ol><li>如果操作数中存在对象类型，先将其按照上节介绍的转换规则，转成原始值；</li><li>如果操作数已经全部是原始值，此时如果有字符串类型的原始值，那么将两个原始值都转为字符串后，按字符串拼接操作处理；</li><li>如果操作数已经全部是原始值且没有字符串类型的，那么将操作数都转为数字类型后，按数字的加法处理;</li><li>NaN 加上任意类型的值后都是 NaN.</li></ol><p>以上的处理规则是针对于通过 &quot;+&quot; 运算符处理两个操作数的场景，如果一个表达式中存在多个 &quot;+&quot; 运算符，那么分别以优先级计算过程中，每一次计算 &quot;+&quot; 运算符的两个操作数使用上述规则进行处理。</p><p>举个例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>1 + 2    // =&gt; 3, 因为操作数都是数字类型的原始值
1 + &quot;2&quot;  // =&gt; &quot;12&quot;，因为操作数中存在字符串类型的原始值，所以是按字符串拼接来处理
1 + {}   // =&gt; &quot;1[object Object]&quot;，因为有操作是对象类型，先将其转为原始值，{} 转为原始值为字符串 &quot;[object Object]&quot;，所以将操作数都转为字符串后，按字符串拼接处理
1 + true // =&gt; 2，因为两个都是原始值，且没有字符串类型，所以将 true 转为数字类型后是 1，按加法处理
1 + undefined // =&gt; NaN，因为 undefined 转为数字类型后为 NaN，NaN 与任何数运算结果都为 NaN 

1 + 2 + &quot; dasu&quot;  // =&gt; &quot;3 dasu&quot;， 因为先计算 1+2=3，然后再计算 3 + &quot; dasu&quot;，所以是 &quot;3 dasu&quot;
1 + (2 + &quot; dasu&quot;) // =&gt; &quot;12 dasu&quot;，因为先计算 2 + &quot; dasu&quot; = &quot;2 dasu&quot;，再计算 1 + &quot;2 dasu&quot; = &quot;12 dasu&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 &quot;+&quot; 运算符在编程中很常见，也很常用，而 JavaScript 又是弱类型语言，变量无需声明类型，那么程序中，&quot;+&quot; 运算符的两个操作数究竟是哪两种类型在进行计算，结果又会是什么，这点在心里至少是要明确的。</p><h3 id="和-相等运算符" tabindex="-1"><a class="header-anchor" href="#和-相等运算符" aria-hidden="true">#</a> &quot;==&quot; 和 &quot;===&quot; 相等运算符</h3><p>&quot;==&quot; 和 &quot;===&quot; 都是用于判断两个操作数是否相等的运算符，但它们是有区别的。</p><p>&quot;==&quot; 比较相等的两个操作数会自动进行一些隐式的类型转换后，再进行比较，俗称不严格相等。</p><p>&quot;===&quot; 比较相等的两个操作数，不会进行任何类型转换，相等的条件就是类型一样，数值也一样，所以俗称严格相等。</p><p>而 &quot;!=&quot; 和 &quot;!==&quot; 自然就是这两个相等运算符的求反运算。下面分别来看看：</p><h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> &quot;===&quot;</h4><p>当通过这个运算符来比较两个操作数是否严格相等时，具体规则如下：</p><ul><li>如果两个操作数的类型不相同，则它们不相等</li><li>如果其中一个操作数是 NaN 时，则它们不相等（因为 NaN 跟任何数包括它本身都不相等）</li><li>如果两个操作数都是对象类型，那么只有当两个操作数都指向同一个对象，即它们的引用一样时，它们才相等</li><li>如果两个操作数都是字符串类型时，当字符串一致时，在某些特殊场景下，比如具有不同编码的 16 位值时，它们也不相等，但大部分情况下，字符串一致是会相等，但要至少清楚不是百分百</li><li>如果两个操作数都是布尔类型、数字类型、null、undefined，且值都一致时，那它们相等</li></ul><p>总之，这里的规则跟 Java 里的相等比较类似，Java 里没有严格不严格之分，它处理的规则就是按照 JavaScript 这里的严格相等来处理，所以大部分比较逻辑可参考 Java。</p><p>需要注意的就是，NaN 与任何数包括它本身也不相等、同一个字符串内容可能会有不同的编码值，所以并不是百分百相等。</p><h4 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> &quot;==&quot;</h4><p>这个通常称为不严格相等，当比较是否相等的两个操作数的数据类型不一样时，会尝试先进行转换，然后再进行比较，相比于上面的 &quot;===&quot; 严格相等运算符来说，它其实就是放宽了比较的条件，具体规则如下：</p><ul><li>如果两个操作数的类型一样，那么规则跟 &quot;===&quot; 一样</li><li>如果一个类型是 null，另一个类型是 undefined，此时，它们也是相等的</li><li>如果一个类型是数字，另一个类型是字符串，那么先将字符串转为数字，再进行比较</li><li>如果一个类型是布尔，先将布尔转成 1（true）或 0（false），然后再根据当前两个类型是否需要再进一步处理再比较</li><li>如果一个类型是对象，那么先将对象转换成原始值，然后再根据当前两个类型是否需要再进一步处理再比较</li></ul><p>总之，&quot;==&quot; 的比较相对于 &quot;===&quot; 会将条件放宽，下面可以看些例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>null === undefined    // =&gt; false，两个类型不一样
null == undefined     // =&gt; true，不严格情况下两者可认为相等   

1 == &quot;1&quot;              // =&gt; true，&quot;1&quot; 转为数字 1 后，再比较
1 == [1]              // =&gt; true，[1] 先转为字符串 &quot;1&quot;，此时等效于比较 1 == &quot;1&quot;，所以相等
2 == true             // =&gt; false，因为 true 先转为数字 1，此时等效于比较 2 == 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="逻辑与" tabindex="-1"><a class="header-anchor" href="#逻辑与" aria-hidden="true">#</a> &quot;&amp;&amp;” 逻辑与</h3><p>逻辑与就是两个条件都要满足，这点跟 Java 里的逻辑与操作 &amp;&amp; 没有任何区别。</p><p>但 JavaScript 里的逻辑与 &amp;&amp; 操作会更强大，在 Java 里，逻辑与 &amp;&amp; 运算符的两个操作数都必须是关系表达式才行，而且整个逻辑与表达式最终的结果只返回 true 或 false。</p><p>但在 JavaScript 里，允许逻辑与 &amp;&amp; 运算符的两个操作数是任意的表达式，而且整个逻辑与 &amp;&amp; 表达式最终返回的值并不是 true 或 false，而是其中某个操作数的值。</p><p>什么意思，来看个例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>x == 0 &amp;&amp; y == 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这是最基本的用法，跟 Java 没有任何区别，当且仅当 x 和 y 都为 0 时，返回 true，否则返回 false。</p><p>上面那句话，是从这个例子以及延用 Java 那边对逻辑与 &amp;&amp; 运算符的理解所进行的解释。</p><p>但实际上，在 JavaScript 里，它是这么处理逻辑与 &amp;&amp; 运算符的：</p><ul><li>如果左操作数的值是假值，那么不会触发右操作数的计算，且整个逻辑与 &amp;&amp; 表达式返回左操作数的值</li><li>如果左操作数的值是真值，那么整个逻辑与 &amp;&amp; 表达式返回右操作数的值</li><li>假值真值可以通俗的理解成，上节介绍各种数据类型间的转换规则中，各类型转换为布尔类型的值，转为布尔后为 true，表示这个值为真值。反之，为假值。</li></ul><p>所以，按照这种理论，我们再来看看上面那个例子，首先左操作数是个关系表达式：<code>x == 0</code>，如果 x 为 0，这个表达式等于 true，所以它为真值，那么整个逻辑与 &amp;&amp; 表达式返回右操作数的值。右操作数也是个关系表达式：<code>y == 0</code>，如果 y 也等于 0，右操作数的值就为 true，所以整个逻辑与 &amp;&amp; 表达式就返回 true。</p><p>虽然结果一样，但在 JavaScript 里对于逻辑与 &amp;&amp; 表达式的解释应该按照第二种，而不是按照第一种的 Java 里的解释。如果还不理解，那么再来看几个例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>function getName() {
	return &quot;dasu&quot;
}

null &amp;&amp; getName()   //输出 =&gt; null，因为左操作数 null 转成布尔是 false，所以它是假值，所以逻辑与 &amp;&amp; 直接返回左操作数的值 null

getName &amp;&amp; getName()  //输出 =&gt; &quot;dasu&quot;，因为左操作数是一个函数对象，如果该函数对象被声明定义了，那么转为布尔值就是 true，所以逻辑与 &amp;&amp; 表达式返回右操作数的值，右操作数是 getName()，调用了函数，返回了 &quot;dasu&quot;，所以这个就是这个逻辑与 &amp;&amp; 表达式的值。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一个逻辑与表达式：<code>null &amp;&amp; getName() </code> 会输出 null，是因为左操作数 null 转成布尔是 false，所以它是假值，所以逻辑与 &amp;&amp; 直接返回左操作数的值 null。</p><p>第二个逻辑与表达式：<code>getName &amp;&amp; getName() </code> 会输出 &quot;dasu&quot;，是因为左操作数是一个函数对象，如果该函数对象被声明定义了，那么转为布尔值就是 true，所以逻辑与 &amp;&amp; 表达式返回右操作数的值，右操作数是 getName()，调用了函数，返回了 &quot;dasu&quot;，所以这个就是这个逻辑与 &amp;&amp; 表达式的值。</p><p>所以 JavaScript 里的逻辑与 &amp;&amp; 表达式会比 Java 更强大，它有一种应用场景：</p><h4 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>function queryName(callback) {
    //... 
    
    //回调处理
    callback &amp;&amp; callback();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 中，我们提供回调机制的处理通常是定义了一个接口，然后接口作为函数的参数，如果调用的时候，传入了这个接口的具体实现，那么在内部会去判断如果传入的接口参数不为空，就调用接口里的方法实现通知回调的效果。</p><p>在 JavaScript 里实现这种回调机制就特别简单，通过逻辑与 &amp;&amp; 表达式，一行代码就搞定了，如果有传入 callback 函数，那么 callback 就会是真值，逻辑与 &amp;&amp; 表达式就会去执行右操作数的 callback()。</p><p>当然，如果你想严谨点，你可以多加几个逻辑与 &amp;&amp; 表达式来验证传入的 callback 参数是否是函数类型。</p><h3 id="逻辑或" tabindex="-1"><a class="header-anchor" href="#逻辑或" aria-hidden="true">#</a> &quot;||&quot; 逻辑或</h3><p>逻辑或 || 跟逻辑与 &amp;&amp; 就基本是一个东西了，理解了上面讲的逻辑与 &amp;&amp; 运算符的理论，那么自然也就能够理解逻辑或 || 运算符了。</p><p>它们的区别，仅在于对表达式的处理，逻辑或 || 表达式是这么处理的：</p><ul><li>如果左操作数的值是真值，那么不会触发右操作数的计算，且整个逻辑或 || 表达式返回左操作数的值</li><li>如果左操作数的值是假值，那么整个逻辑或 || 表达式返回右操作数的值</li><li>假值真值可以通俗的理解成，上节介绍各种数据类型间的转换规则中，各类型转换为布尔类型的值，转为布尔后为 true，表示这个值为真值。反之，为假值。</li></ul><p>这里就直接来说下它的一个应用场景了：</p><h4 id="应用场景-1" tabindex="-1"><a class="header-anchor" href="#应用场景-1" aria-hidden="true">#</a> 应用场景</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>function queryNameById(id) {
    //参数的默认值
    id = id || 10086;
    //...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>处理参数的默认值，如果调用函数时，没有传入指定的参数时。</p><p>当然，还有其他很多应用场景。总之，善用逻辑与 &amp;&amp; 和逻辑或 || 运算符，可以节省很多编程量，同时实现很多功能。</p><h2 id="逗号运算符" tabindex="-1"><a class="header-anchor" href="#逗号运算符" aria-hidden="true">#</a> &quot;,&quot; 逗号运算符</h2><p>在 Java 中，&quot;,&quot; 逗号只用于在声明同一类型变量时，可同时声明，如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>int a, b, c;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 JavaScript 里，&quot;,&quot; 逗号运算符同样具有这个功能，但它更强大，因为带有 &quot;,&quot; 逗号运算符的表达式会有一个返回值，返回值是逗号最后一项操作数的值。</p><p>逗号运算符跟逻辑与和逻辑或唯一的区别，就在于：逗号运算符会将每一项的操作数都进行计算，而且表示式一直返回最后一项的操作数的值，它不管每个操作数究竟是真值还是假值，也不管后续操作数是否可以不用计算了。</p><p>举个例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>function getName() {
	return &quot;dasu&quot;
}

function queryNameById(id, callback) {
    id = id || 10086;
    callback &amp;&amp; callback();
}

function myCallback() {
    console.log(&quot;I am dasu&quot;);
}

var me = (queryNameById(0, myCallback), getName()) //me会被赋值为 &quot;dasu&quot;,且控制台输出 &quot;I am dasu&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://upload-images.jianshu.io/upload_images/1924341-5e1f6e7688a10452.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="逗号运算符"></p><p>变量 me 会被赋值为 &quot;dasu&quot;，且控制台输出 &quot;I am dasu&quot;。</p><h3 id="typeof-运算符" tabindex="-1"><a class="header-anchor" href="#typeof-运算符" aria-hidden="true">#</a> typeof 运算符</h3><p>返回指定操作数的数据类型，例：</p><p><img src="https://upload-images.jianshu.io/upload_images/1924341-7e4ae9891a2780a0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" alt="typeOf"></p><p>在 JavaScript 中数据类型大体上分两类：原始类型和引用类型。</p><p>原始类型对应的值是原始值，引用类型对应的值为对象。</p><p>对于原始值而言，使用 typeof 运算符可以获取原始值所属的原始类型，对于函数对象，也可以使用 typeof 运算符来获取它的数据类型，但对于其他自定义对象、数组对象、以及 null，它返回的都是 object，所以它的局限性也很大。</p><h3 id="delete-运算符" tabindex="-1"><a class="header-anchor" href="#delete-运算符" aria-hidden="true">#</a> delete 运算符</h3><p>delete 是用来删除对象上的属性的，因为 JavaScript 里的对象有个特性，允许在运行期间，动态的为对象添加某个属性，那么，自然也允许动态的删除属性，就是通过这个运算符来操作。</p><p>这个在对象一节还会拿出来讲，因为并不是所有的属性都可以成功被删除的，属性可以设置为不可配置，此时就无法通过 delete 来删除。</p><p>另外，之前也说过，在函数外声明的全局变量，本质上都是以属性的形式被存在在全局对象上的，但这些通过 var 或 function 声明的全局变量，无法通过 delete 来进行删除。</p><p>之前也说过，如果在声明变量时，不小心漏掉了 var 关键字，此时程序并不会出异常，因为漏掉 var 关键字对一个不存在的变量进行赋值操作，会被 js 解释器认为这行代码是要动态的为全局对象添加一个属性，这个动态添加的属性就可以通过 delete 来进行删除，因为动态添加的属性默认都是可配置的。</p><h3 id="instanceof-运算符" tabindex="-1"><a class="header-anchor" href="#instanceof-运算符" aria-hidden="true">#</a> instanceof 运算符</h3><p>在 Java 中，可以通过 instanceof 运算符来判断某个对象是否是从指定类实例化出来的，也可以用于判断一群对象是否属于同一个类的实例。</p><p>在 JavaScript 中有些区别，但也有些类似。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>var b = {}
function A() {}
A.prototype = b;
var a = new A();
if (a instanceof A) { //符合，因为 a 是从A实例化的，继承自A.prototype即b
    console.log(&quot;true&quot;); 
}

function B() {}
B.prototype = b;
var c = new B();
if (c instanceof A) {//符合，虽然c是从B实例化的，但c也同样继承自b，而A.prototype指向b，所以满足
    console.log(&quot;true&quot;);
}
if (c instanceof Object) {//符合，虽然 c 是继承自 b，但 b 继承自 Object.prototype，所以c的原型链中有 Object.prototype
    console.log(&quot;true&quot;);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JavaScript 中，instanceof 运算符的左侧是对象，右侧是构造函数。但他们的判断是，只要左侧对象的原型链中包括右侧构造函数的 prototype 指向的原型，那么条件就满足，即使左侧对象不是从右侧构造函数实例化的对象。</p><p>例子代码看不懂么事，这个在后续介绍原型时，还会再拿出来说，先清楚有这么个运算符，运算符大概的作用是什么就可以了。</p>`,84);function q(g,f){const i=l("ExternalLinkIcon");return d(),s("div",null,[o,p,a("ul",null,[c,a("li",null,[a("a",v,[e("MDN web docs"),n(i)])]),a("li",null,[a("a",m,[e("Github:smyhvae/web"),n(i)])]),a("li",null,[a("a",b,[e("Github:goddyZhao/Translation/JavaScript"),n(i)])])]),h])}const N=t(r,[["render",q],["__file","前端入门9-JavaScript语法之运算符.html.vue"]]);export{N as default};
