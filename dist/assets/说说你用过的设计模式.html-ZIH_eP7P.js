import{_ as e,o as i,c as a,d as n}from"./app-xJrSpaa5.js";const d={},r=n(`<h1 id="说说用过的设计模式" tabindex="-1"><a class="header-anchor" href="#说说用过的设计模式" aria-hidden="true">#</a> 说说用过的设计模式</h1><p>设计模式其实是种编程思想，提高代码的维护性、可读性</p><p>有时，即使你不知道具体设计模式的名称，实现方式，但在日常编程中，已经不知不觉的使用上了</p><p>设计模式有五大基本原则思想：</p><ul><li>单一职责（人话：方法或类尽量不编写过长代码）</li><li>开闭原则（人话：新功能最好不要在原有代码上做修改，而是应该通过继承等其他方式实现）</li><li>里氏替换原则（人话：父类出现的地方，都可以用子类替代）</li><li>接口隔离原则（人话：不要把所有抽象操作都定义在同一个接口里，可以多定义几个接口）</li><li>依赖倒置原则（人话：持有引用时，最好可以持有抽象类型的引用，而不是直接持有具体子类类型）</li></ul><p>设计模式有很多种，大致可以分成三类：创建型、行为型、结构型</p><p>下面说说还能在项目中记起使用过的几种：</p><ul><li>创建型：单例模式、工厂模式</li><li>行为型：观察者模式、状态模型、策略模式</li><li>结构型：适配器模式、组合模式、外观模式、装饰模式、代理模式</li></ul><h3 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式" aria-hidden="true">#</a> 单例模式</h3><p>单例模式，也就是整个程序中只有一个实例，从实现上来说，也就是进程级别的缓存，该进程里共用这么一个缓存</p><p>实现方式有懒汉式和饿汉式，简单理解也就是需要用的时候才实例化，还是一开始就实例化，饿汉式是一开始就实例化了，所以是线程安全，但在不需要时候的期间，就是耗资源了</p><p>懒汉式是需要使用时才实例化，这样就存在一个问题，多个线程如果同时需要呢，所以需要针对场景考虑线程安全问题，实现方式上可以有加锁、双重判断内层加锁、内部静态类、枚举方式</p><p>前端其实不需要单例模式的应用场景，因为，js 是单线程模式，不存在多线程协作场景</p><h3 id="简单工厂模式" tabindex="-1"><a class="header-anchor" href="#简单工厂模式" aria-hidden="true">#</a> 简单工厂模式</h3><p>工厂模式可以分多钟：简单工厂模式、抽象工厂模式、工厂模式</p><p>具体区别，我不清楚，简单来说，工厂模式就是统一创建对象的地方，是个工具人</p><p>项目里使用到的场景，基本是一些工厂方法，也就是通过接收不同参数，实例化不同对象并返回</p><h3 id="观察者模式" tabindex="-1"><a class="header-anchor" href="#观察者模式" aria-hidden="true">#</a> 观察者模式</h3><p>前端里，其实，DOM 事件的监听就是观察者模式了</p><p>观察者模式是指，有某个观察者，当它观察的对象的行为或状态发生变更时，就做出相应响应行为</p><p>所以，实现上，其实也就是回调函数的方式，回调函数就可以看成是响应行为，由被观察者在满足条件时，来通知触发</p><h3 id="状态模式" tabindex="-1"><a class="header-anchor" href="#状态模式" aria-hidden="true">#</a> 状态模式</h3><p>状态模式，主要是状态机场景里需要使用</p><p>简单说，就是存在各种状态，不同状态间可切换，对应着不同的行为</p><p>之前的项目里有过一个播放器 SDK，需要对播放器行为进行一层业务层面的抽象封装</p><p>而播放器状态就多了：开始播放、播放中、播放结束、缓冲中、缓冲失败、缓冲结束等等，不同状态对应不同行为，还可以相互切换，所以用状态模式来实现就比较方便了</p><p>实现方式上，其实也就是通过接口，将各种行为抽象到接口中，然后有各种具体子类实现了该接口，各自负责各自状态对应的行为，而有一个状态机管理者，它持有着抽象的状态引用，以及维护着所有具体子类，运行中，由它来决定，状态发生了什么变化，调用哪个子类的行为</p><h3 id="策略模式" tabindex="-1"><a class="header-anchor" href="#策略模式" aria-hidden="true">#</a> 策略模式</h3><p>策略模式其实跟状态模式很像，但它主要解决的是，提供不同的策略行为</p><p>比如说，之前负责一个用户行为信息收集的模块，该模块对外就是收集用户行为信息，但根据不同的用户行为：点击行为、购买行为等会进行不同的信息收集行为</p><p>这时候就可以用策略模式了</p><p>不同行为对应着不同的策略模式，但它们都可以抽象成同一个行为：收集用户信息</p><p>所以，实现上也是有一个管理者，维护者所有的具体策略行为子类，但持有的是抽象行为对象，运行中，具体是采用哪种策略行为，就由外部调用时，传入不同参数决定</p><p>这里顺道讲讲前端里的实现，因为 js 并不是基于 class 的语言，而且可动态增删属性，属性又可以是任意类型的，所以实现状态模式、策略模式、工厂模式都特别简单</p><p>就是定义个对象，以属性 key 值来作为不同状态标识符也好、不同策略行为的类型也好，直接通过访问对象的属性方式来决定采用的是哪种行为，因为属性值也可以存储函数</p><p>举个例子，可以用来解决 if 的问题：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if(xxx) {}
else if(xxx) {}
else if(xxx) {}
else if(xxx) {}
else if(xxx) {}

// 优化
var obj = {
  xxx1: () =&gt; {},
  xxx2: () =&gt; {},
  xxx3: () =&gt; {},
  xxx4: () =&gt; {},
};
obj[xxx]();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="适配器模式" tabindex="-1"><a class="header-anchor" href="#适配器模式" aria-hidden="true">#</a> 适配器模式</h3><p>适配器模式，简单说，就是把源数据结构转换成模板数据结构</p><p>也就是增加一层适配层，将不符合所需的数据进行一层处理，转换，适配</p><p>比如在安卓里列表所需的 Adapter 就是适配器模式</p><h3 id="外观模式" tabindex="-1"><a class="header-anchor" href="#外观模式" aria-hidden="true">#</a> 外观模式</h3><p>外观模式，统一对外提供唯一的接口，但由它来跟内部一系列接口打交道</p><p>就比如 Spring MVC，Controller 的请求的入口，但内部是去跟数据库、还是其他微服务交互无所谓</p><p>再比如 nginx，浏览器统一跟同一个端口交互，但 nginx 需要去跟内部一系列端口交互</p><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3><p>装饰模式，简单说，在原有对象行为上，进行扩展</p>`,47),l=[r];function p(s,h){return i(),a("div",null,l)}const t=e(d,[["render",p],["__file","说说你用过的设计模式.html.vue"]]);export{t as default};
