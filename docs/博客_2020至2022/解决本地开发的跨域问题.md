本篇讲的是本地开发时的跨域问题，即运行类似 localhost:8080 来开发程序时，接口出现跨域的场景处理

通常，前端独立部署的项目是不会有这种问题出现的，因为前后端分开部署，本身就已经处于跨域场景，所以，后端接口基本都会在请求的返回头加上支持跨域的响应头

但在一些前端仍旧跟后端项目部署在同一站点的场景下，后端接口如果没有在响应头上加上跨域支持，那么，本地开发时，就会出现跨域问题，阻塞本地开发

解决方案有很多，随便挑一种自己熟悉、用惯的即可

解决方案的思路其实就两点：想办法不跨域；想办法支持跨域

# 解决方案一：后端响应头加字段

这是对前端来说，最简单的方式，但后端估计不好处理

如果后端不处理，前端来解决本地开发跨域问题的话，终归是需要借助到代理工具（除非设置 chrome 不拦截跨域），所以，建议，一定一定要掌握一款代理工具的使用，随便你用选，webpack 的代理配置也行、whistle 更好

# 解决方案二：代理指定域名到本地

举个例子：

将访问 `https://vengineer-test.myyscm.com/wework/home` 的请求代理到访问 `http://localhost:8080/wework/home`

这样，对于浏览器来说，从头到尾都是在前者的站点下的请求，自然就不存在跨域

所以，这是一种借助代理来让本地开发不存在跨域场景的思路

具体操作可以借助 whistle 代理工具的配置，如下：

![](./images/%E8%A7%A3%E5%86%B3%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.png)

# 解决方案三：配置请求拦截，响应头加上支持跨域字段

这是一种把后端不做的事，前端通过代理方案来做的思路

具体操作参考方案二的图片，即上图

简单说，就是随便借助一种代理工具（这里用了 whislte），然后拦截请求，并在响应头上加上支持跨域的字段，比如：

![](./images/%E8%A7%A3%E5%86%B3%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%982.png)

# 解决方案四：配置 webpack 的 proxy 支持跨域

这是一种借助 webpack 来支持跨域的思路

建议把 loglevel 都设为 debug，这样才方便查看请求是否有被代理

这种方案上手简单，但不实用（一是每次修改都需要重跑服务、二是看不到具体代理的详细情况）

![](./images/%E8%A7%A3%E5%86%B3%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%983.png)

# 解决方案五：设置 chrome 浏览器不处理跨域

这是一种简单粗暴是方案

chrome 可以通过某种手动，把跨域的限制给关闭掉，这样本地开发时，就不会有跨域问题了

具体操作方案自行网上搜索，不是很建议这种方案，虽然很简单粗暴，一劳永逸，但有时候会让你忘记提醒后端开发人员接口需要做跨域支持

# 最后

跨域问题，建议还是要掌握，可以顺便自行再去了解下，为什么会有跨域，跨域怎么出现的，而且出现跨域后，有哪些方案解决

当你网上看了一堆文章后，你会发现，大伙讲的都大同小异，但讲的都是生产环境的跨域怎么解决，基本都没有人提本地开发时的跨域怎么处理

为什么不提呢？

这是默认你已经掌握并了解了什么是跨域了，当你清楚了跨域怎么来的，自然就有办法解决自己本地开发时的跨域问题
