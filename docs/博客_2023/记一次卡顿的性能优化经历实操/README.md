# 记一次卡顿的性能优化经历实操

本篇的性能优化不是八股文类的优化方案，而是针对具体场景，具体分析，从排查卡顿根因到一步步寻找解决方案，甚至是规避等方案来最终解决性能问题的经历实操

所以，解决方案可能不通用，不适用于你的场景，但这个解决过程是如何一步步去处理的，解决思路是怎么样的，应该还是可以提供一些参考、借鉴意义的

当然，也许你还有更好的解决方案，也欢迎评论教一下，万分感谢

## 问题现象

我基于 `twaver.js` 库实现了一个园区内网络设备的拓扑呈现，连线表示设备间的拓扑关系，线路上支持流动动画、告警动画、链路信息等呈现，如：

![](./images/topo1.gif)

但当呈现的节点数量超过 1000 后，动画开始有点丢帧，操作有点点滞后感

超过 5000 个节点后，页面就非常的卡顿，难以操作

所以，就开始了性能优化之路

## 猜测&验证

### 猜测 1：Vue 框架的响应式处理导致的性能瓶颈

之所以有这个猜测是因为，我在官方给的 demo 上体验时，上万个节点时都不卡顿，更何况是一千个节点而已

而我的项目跟官方 demo 的差异有两块：

- 我用 vue 框架开发，官方 demo 用的纯 html + js
- 我功能已经开发完，所以实际上还参杂了其他各种实现的代码，官方 demo 很简单的纯节点和链路

为了验证这个猜想，我另外搞了个空项目，纯粹就只是把官方 demo 的代码迁移到 vue 上运行起来而已，如：

**【10000 个节点，20000 条连线，twaver 官方 demo 耗时 250ms，不卡顿】**

![](./images/twaver2.gif)

**【10000 个节点，20000 条连线，vue 实现的 demo 耗时 11500ms，操作上有 0.5s 的滞后感】**

![](./images/twaver3.gif)

**同样的代码，同样的数据量，区别仅仅是一个用纯 js 实现，一个用 vue 实现，但两边的耗时差异将近 45 倍**

所以就开始思考了，Vue 框架能影响到性能问题的是什么？无非不就是响应式处理，内部会自动对复杂对象深度遍历去配置 setter, getter 来拦截对象属性的读写

而 twaver 的对象结构又非常复杂，就导致了一堆无效的响应式处理耗时资源：

![](./images/topo3.gif)

看到没有，twaver 的两个变量 box 和 network，内部结构非常复杂，N 多的内嵌对象，全部都被响应式处理，这占用的资源是非常恐怖的

_（注：Vue2.x 版本可以直接在开发者工具面板上查看对象内部是否有 setter 和 getter 就知道这个对象是否有被响应式处理）_

但我们其实又不需要它能够响应式，我们只是想使用 twaver 对象的一些 api 而已

那么该怎么来避免 Vue 对这些数据进行的响应式处理呢？

下一章节里再具体介绍解法，至少到这里已经明确了卡顿的根因之一是 Vue 对 twaver 的数据对象进行了响应式处理而引发的性能瓶颈

### 猜测 2：动画太多导致的性能瓶颈

这个应该是显而易见的根因之一了，每条链路上都会有各种动画，而实现上又是每条链路内部自己维护自己的动画管理器（twaver.Animate）

简单去捞了下 twaver 内部源码实现，动画管理器用了 `requestAnimationFrame` 来实现动画帧，用了 `setTimeout` 来实现动画的延迟执行

那么当节点成千上万时，肯定会卡顿，毕竟这么多异步任务

而之所以会这么实现，原因之一是官方给的链路动画 demo 就是这么做的，当初做的时候直接用 demo 方案来实现了

而 demo 显然只是介绍链路动画怎么实现而已，不会给你考虑到极端场景的性能瓶颈问题

那么怎么解决呢？不难，无非就是抽离复用 + 按需刷新思路而已，具体也是下面讲解

### 猜测 3：一次性呈现的节点链路太多导致的性能瓶颈

这也是显而易见的根因之一，就像长列表问题一样，一次性呈现的节点链路太多了，必然会导致性能瓶颈问题

也不需要去验证了，思考解决方案就行

但这跟长列表实现上有点不太一样，因为 twaver 内部是用 canvas 来绘制节点和链路的，并不是用 dom 绘制，所以虚拟列表那种思路在这里行不通

但本质上的解决都一个样，无非就是一次性没必要呈现这么多节点，因为一屏内又显示不了，没有意义

所以，按照这种思路去寻找解决方案，具体也下面讲讲

### 猜测 4：dom 节点太多导致的性能瓶颈

虽然 twaver 内部是用 canvas 绘制的节点和链路，但当节点毕竟复杂时，比如：

![](./images/topo2.png)

这种时候用 canvas 画不出来，只能用 div 绘制，twaver 也支持 HTMLNode 类型节点，这就意味着也会存在 dom 过多的场景

而 dom 导致的性能问题包括 dom 元素过多，频繁操作 dom

因此解决方案上就是尽量避免创建过多的 dom 元素以及避免频繁操作 dom 即可，具体也下面讲

## 解决方案

### 绕过 Vue 的自动对数据模型进行的响应式处理

Vue2.x 框架内部会自动将声明在 data 里的变量进行响应式处理，第一个想到的是尝试用 Object.freeze 来冻结对象，例如：

`this.box = Object.freeze(new twaver.ElementBox());`

但有两个问题：

- Object.freeze 是浅冻结，不是深度冻结，内嵌的对象好像还是会被响应式处理
- 可能会引发功能异常，因为没法确认三方库内部是否有用到对象的枚举、遍历、修改等能力

那么还有其他什么方案吗？

如果你有阅读源码习惯，直接去看看 Vue 内部响应式处理的相关逻辑，去寻找解决方案。如果没有，那来看个东西：

![](./images/topo4.png)

当我在反复调试时，突然发现 Vue 内部有很多以 `_` 下划线为前缀开头的变量，或者是 `$` 为前缀的变量，而且这些变量都没有被响应式处理。

于是我尝试把我的变量改成 `_box`， `_network`，结果果然没有被响应式处理。

如果你好奇，那么可以跟着来看看 Vue 源码（Vue 2.6.1 版本）

TODO：

如果接着往下看你会发现，Vue 内部用来响应式处理数据的是 TODO

所以，如果我们这么使用，也一样可以避免被响应式处理：

```javascript
const box = new twaver.ElementBox();
box.__v_skip = true; // 这个是关键
this.box = box;

const network = new twaver.vector.Network(this.box);
network.__v_skip = true; // 这个是关键
this.network = network;
```

当然，以上都是 Vue2.x 版本的解决方案，Vue3.x 直接就是显示使用了，就没这么多烦恼了。

**【举一反三】**

当用到其他一些三方库，三方库变量又不是全局而是当前组件内的局部变量时，都会存在被 Vue 响应式处理的问题。

### 共同复用全局的动画管理器 + 按需刷新

### 交互上进行规避，如增加默认折叠、展开处理

### dom 节点的懒创建 + 缓存和复用

## 小结

其实，大多数的性能问题本质上都是大同小异的原因：

- **无意义的内存占用过高**，如 Vue 对 twaver 数据对象的响应式处理
- **一次性处理的东西过多**，如渲染上万个节点
- **短时间内频繁执行某些其实没意义的操作**，如实时刷新即使在屏幕外的动画
- **反复创建、销毁行为**，如 dom 节点的反复创建

所以性能优化的难点之一在于排查根因，找到问题所在后，才能去着手思考对应的解决方案

而解决思路无外乎也是大同小异：

- 按需使用、懒加载
- 缓存和复用
- 规避方法




# 性能优化策略

已知的会导致性能问题的场景如下：

- 动画太多（每条链路的流动动画、告警图标闪烁动画）
- 节点太多
- vueNode 节点太多（即 HTMLNode，用 vue 实现的自定义节点，本质是使用 dom + 定位绘制，不是使用 canvas 直接绘制）
- Vue 对 twaver 对象进行了响应式处理导致的性能消耗

## 动画太多的性能问题解决

【原实现方案】

- 每条链路内部自己 new twaver.Animate 来刷新自己链路的动画
- 每个图标内部自己 new twaver.Animate 来刷新自己的闪烁动画

【弊端】

- 一个 twaver.Animate 内部实现应该就是类似一个定时器，当节点和链路量大时，将有 N 个做着一样事情的定时器非常占用资源
- 每条链路和图标内部无时无刻不在根据定时器刷新着自己的动画帧，即使已经不在当前可见范围内，也仍旧占用资源

【新解决方案】

- 移除链路和图标内部各自的 twaver.Animate 对象，统一交由全局动画管理器（GlobalAniamtion）来全局共用同一个动画定时器即可
- 全局动画管理器持有 network 拓扑画布对象，每次更新动画帧时，都先获取当前可视范围内的拓扑节点和链路，做到局部动画更新，避免浪费无意义的资源在更新不可见的节点上
- 节点内部绘制时再次判断自己当前是否可见，进一步过滤掉不可见节点的绘制刷新
- 同时增加动画开关，让用户可以显示的选择启用或关闭动画。但是当一些极端场景，比如全部展开操作时，发现数量达到一定时，会自动将动画进行关闭处理并告知用户

【思想】

- 复用 + 按需刷新

## 节点太多的性能问题解决

【背景】

- 由于节点渲染是直接用 twaver 实现，而且要用到 twaver 内部的节点位置计算算法、搜索定位等场景功能，无法用按需渲染的思路去解决。
- 因为很难计算出当前可视范围内到底该渲染的是哪些节点、而且即使用懒加载，也会导致搜索定位等功能失效
- 总之，很难解决按需渲染、懒加载这种思路所带来的副作用影响点，所以不考虑这些思路了

【新解决方案】

- 既然技术上难以解决，那么就从交互方面去提供解决方案
- 增加节点的默认折叠处理方案，当超过一定数量时，默认把子孙节点折叠起来，这样能够避免一次性渲染太多节点
- 同时增加展开/折叠全部节点的快捷操作
- 由于孤点没有树形结构，因此当超过一定数量孤点时，需要另外处理折叠逻辑
- 搜索节点时，发现节点处于折叠状态的话，要自动进行展开处理

## vueNode 节点太多的性能问题解决

【背景】

- twaver 支持用 HTMLNode 自定义节点，由于原生 html+js 代码不方便维护，这里封装了 vueNode 来用 vue 实现自定义节点
- vueNode 本质也是 dom + 定位实现的自定义节点，那么当节点过多时，就转变成 dom 元素过多，而 dom 元素过多必然会导致卡顿问题
- vue 有自己的生命周期，由于不是 SPA 方式使用，如果没有手动处理好销毁周期的话，容易造成内存泄漏

【新解决方案】

- vueNode 内部重写了 twaver 绘制 dom 元素的方法逻辑，改造成懒加载方式，即当节点不在页面可视范围内的话，不挂载 dom 到界面上，避免一次性渲染太多 dom
- 收集管理所有的 vueNode，当销毁时，手动触发 vue 的 destroy，及时销毁资源

## Vue 对 twaver 对象进行了响应式处理导致的性能消耗

【背景】

- 这点了解的人可能不多，但确实是个问题，因为经常出现用 twaver 官方 demo 体验时，明明支持上万个节点，基本一样的代码，搬到 vue 项目里，就下降成只支持几千个节点了
- 这是由于 Vue 会对 data 变量进行递归的响应式处理，每个属性都重写 setter, getter, 用闭包持有依赖者等占用资源
- 而当把 twaver 的变量，如 network, box, node 等对象声明在 data 里时，由于 twaver 对象结构都非常庞大且复杂，响应式处理后非常占用资源，但这些其实都是 twaver 内部需要使用的，根本没必要进行响应式处理

【解决方案】

- 可以用 Object.freeze 递归处理，但可能引起其他问题，毕竟不清楚 twaver 内部有没有需要依赖到相关能力
- 变量以 _ 下划线作为前缀，Vue 内部在 created 生命周期创建 data 数据变量对象时，会绕过 _ 下划线为前缀的变量，因此就可以借此绕过它的响应式处理
