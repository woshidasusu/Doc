# 讲讲 angular 的渲染优化

前端的响应式系统，也就是三大框架所实现的双向绑定，其实要解决的都是模型到视图这个方向的更新

如何知道更新的时机，以及如何确定更新的视图是哪些，就是框架层面所要解决的两个关键问题

angular 是通过对所有可能会造成界面刷新的操作都进行了一层封装，比如所有的 dom 原生事件，异步事件，setTimeout 这些都经过封装，当被调用时，angular 就认为界面有可能刷新，就会去触发它的脏数据检测机制

脏数据检测机制通俗讲就是会把模板代码里所有绑定的表达式、变量等的值重新计算一遍，然后跟上一时刻比对，当发现不一样时，说明这块视图数据脏了，那就知道了这块视图是需要更新的了

那么这个过程是如何优化的呢？

在 angular 里有组件的概念，angular 做成的单页应用，页面其实都是由组件构成，从根组件开始，不管嵌套子组件形成一颗组件树

这里的组件可以理解成是对多个原生 html 元素自定义的组合后的集合统称

每个组件都有自己对应的一个变化检测器，负责该组件的脏数据检测工作

每一次脏数据检测过程，都是从根组件开始，遍历整颗组件树，通知每个组件的变化检测器去进行相关的检测工作，体现在生命周期上，就是当前组件的 `ngDoCheck()` 先调用，然后当子组件检测结束后，会收到 ` ngAfterViewChecked()` 的回调

所以，默认行为下，angular 的每一次脏数据检测过程都会遍历整颗组件树，检测每个组件

当然，支持我们根据场景修改这种检测策略来进行优化，比如有些组件你很明确的视图更新场景，那么这时候就可以通过修改策略，每一次脏检测时，遍历到该组件，就停止，不走默认策略，交由自行决定

具体做法就是，在声明组件的装饰器里通过元数据 changeDetection 修改成 onPush 的策略，这种策略只在组件输入的数据发生变化时才会触发组件的检测，否则直接跳过

然后该组件内部通过依赖注入持有 changeDetectionRef，这个服务提供几种方法，可以让开发者根据需要使用，比如有可以手动触发该组件及其子组件进行检测工作的方法，也有从变化检测树上移除不再接收检测的方法

```typescript
export abstract class ChangeDetectorRef {
  abstract markForCheck(): void;  // 在组件的 metadata 中如果设置了 changeDetection: ChangeDetectionStrategy.OnPush 条件，那么变化检测不会再次执行，除非手动调用该方法
  abstract detach(): void; // 从变化检测树中分离变化检测器，该组件的变化检测器将不再执行变化检测，除非手动调用 reattach() 方法
  abstract detectChanges(): void;  // 重新添加已分离的变化检测器，使得该组件及其子组件都能执行变化检测
  abstract reattach(): void; // 从该组件到各个子组件执行一次变化检测
}
```

常见的优化处理就是，确保组件内部的数据都是通过外部输入，此时可将检测策略修改成 OnPush

这样一来，输入不变就不会触发组件的检测，但需要考虑输入是对象或数组的场景

此时，可借助不可变数据类型，每次修改对象确保生成新的对象，而不是在原对象上进行操作，这样就能让组件接收到输入变化而进行检测

这样优化后，就不会每一次的检测都遍历整颗组件树了