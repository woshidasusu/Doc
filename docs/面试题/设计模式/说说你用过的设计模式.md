# 说说用过的设计模式

设计模式其实是种编程思想，提高代码的维护性、可读性

有时，即使你不知道具体设计模式的名称，实现方式，但在日常编程中，已经不知不觉的使用上了

设计模式有五大基本原则思想：

- 单一职责（人话：方法或类尽量不编写过长代码）
- 开闭原则（人话：新功能最好不要在原有代码上做修改，而是应该通过继承等其他方式实现）
- 里氏替换原则（人话：父类出现的地方，都可以用子类替代）
- 接口隔离原则（人话：不要把所有抽象操作都定义在同一个接口里，可以多定义几个接口）
- 依赖倒置原则（人话：持有引用时，最好可以持有抽象类型的引用，而不是直接持有具体子类类型）

设计模式有很多种，大致可以分成三类：创建型、行为型、结构型

下面说说还能在项目中记起使用过的几种：

- 创建型：单例模式、工厂模式
- 行为型：观察者模式、状态模型、策略模式
- 结构型：适配器模式、组合模式、外观模式、装饰模式、代理模式

### 单例模式

单例模式，也就是整个程序中只有一个实例，从实现上来说，也就是进程级别的缓存，该进程里共用这么一个缓存

实现方式有懒汉式和饿汉式，简单理解也就是需要用的时候才实例化，还是一开始就实例化，饿汉式是一开始就实例化了，所以是线程安全，但在不需要时候的期间，就是耗资源了

懒汉式是需要使用时才实例化，这样就存在一个问题，多个线程如果同时需要呢，所以需要针对场景考虑线程安全问题，实现方式上可以有加锁、双重判断内层加锁、内部静态类、枚举方式

前端其实不需要单例模式的应用场景，因为，js 是单线程模式，不存在多线程协作场景

### 简单工厂模式

工厂模式可以分多钟：简单工厂模式、抽象工厂模式、工厂模式

具体区别，我不清楚，简单来说，工厂模式就是统一创建对象的地方，是个工具人

项目里使用到的场景，基本是一些工厂方法，也就是通过接收不同参数，实例化不同对象并返回

### 观察者模式

前端里，其实，DOM 事件的监听就是观察者模式了

观察者模式是指，有某个观察者，当它观察的对象的行为或状态发生变更时，就做出相应响应行为

所以，实现上，其实也就是回调函数的方式，回调函数就可以看成是响应行为，由被观察者在满足条件时，来通知触发

### 状态模式

状态模式，主要是状态机场景里需要使用

简单说，就是存在各种状态，不同状态间可切换，对应着不同的行为

之前的项目里有过一个播放器 SDK，需要对播放器行为进行一层业务层面的抽象封装

而播放器状态就多了：开始播放、播放中、播放结束、缓冲中、缓冲失败、缓冲结束等等，不同状态对应不同行为，还可以相互切换，所以用状态模式来实现就比较方便了

实现方式上，其实也就是通过接口，将各种行为抽象到接口中，然后有各种具体子类实现了该接口，各自负责各自状态对应的行为，而有一个状态机管理者，它持有着抽象的状态引用，以及维护着所有具体子类，运行中，由它来决定，状态发生了什么变化，调用哪个子类的行为

### 策略模式

策略模式其实跟状态模式很像，但它主要解决的是，提供不同的策略行为

比如说，之前负责一个用户行为信息收集的模块，该模块对外就是收集用户行为信息，但根据不同的用户行为：点击行为、购买行为等会进行不同的信息收集行为

这时候就可以用策略模式了

不同行为对应着不同的策略模式，但它们都可以抽象成同一个行为：收集用户信息

所以，实现上也是有一个管理者，维护者所有的具体策略行为子类，但持有的是抽象行为对象，运行中，具体是采用哪种策略行为，就由外部调用时，传入不同参数决定

这里顺道讲讲前端里的实现，因为 js 并不是基于 class 的语言，而且可动态增删属性，属性又可以是任意类型的，所以实现状态模式、策略模式、工厂模式都特别简单

就是定义个对象，以属性 key 值来作为不同状态标识符也好、不同策略行为的类型也好，直接通过访问对象的属性方式来决定采用的是哪种行为，因为属性值也可以存储函数

举个例子，可以用来解决 if 的问题：

```
if(xxx) {}
else if(xxx) {}
else if(xxx) {}
else if(xxx) {}
else if(xxx) {}

// 优化
var obj = {
  xxx1: () => {},
  xxx2: () => {},
  xxx3: () => {},
  xxx4: () => {},
};
obj[xxx]();
```

### 适配器模式

适配器模式，简单说，就是把源数据结构转换成模板数据结构

也就是增加一层适配层，将不符合所需的数据进行一层处理，转换，适配

比如在安卓里列表所需的 Adapter 就是适配器模式

### 外观模式

外观模式，统一对外提供唯一的接口，但由它来跟内部一系列接口打交道

就比如 Spring MVC，Controller 的请求的入口，但内部是去跟数据库、还是其他微服务交互无所谓

再比如 nginx，浏览器统一跟同一个端口交互，但 nginx 需要去跟内部一系列端口交互

### 其他

装饰模式，简单说，在原有对象行为上，进行扩展

