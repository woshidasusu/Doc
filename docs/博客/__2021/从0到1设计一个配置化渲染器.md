# 从 0 到 1 设计一个配置化渲染器

### 导读

如果你对 paas 化感兴趣

如果你也想寻求一种能够友好地支撑个性化需求开发的方案

那么可以花点时间来阅读本篇文章。读完本文，你可以学习到：

1. **基于元数据的配置化方案的基本原理思想是什么？**
2. **配置化方案设计时主要是需要解决什么问题？**（渲染 + 联动）
3. **元数据的规则如何制定，一个小型完整的配置化渲染器都需要制定哪些方面的元数据规则？**
4. **如何维护、扩展？**
5. **如何平缓过度灰度开关方案的个性化需求功能？**
6. **配置化方案的优缺点？**

### 需求背景和目标

每个方案都是为了解决某个场景下的问题而诞生的，脱离需求背景的方案相对来说会比较经不起考验

所以，在开始设计方案之前，先来看看我们的配置化方案主要想解决的需求背景以及我们想要做成的目标效果是什么：

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/67cfa65b-076d-0797-e7bc-202ec4bb112c.png)

简单说就是：我们想解决租户的个性化需求交付，所以我们想达到页面可配置化的效果

但这个效果说得有点抽象，可配置化？那配置化的粒度是什么？都支持哪些可配置化？

### 个性化需求场景

 所以，再来看看，针对项目目前通过灰度开关方案已实现的所有个性化需求做一下梳理、汇总、分类：

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/aa3e148d-9c78-20aa-9c17-a5a2662449ad.png)

总结分类之后，个性化的需求场景其实并不复杂，无外乎就是一些改样式、改交互、增减字段等等

所以，我们的配置化方案至少需要支持以上这些场景的配置

### 配置化渲染器的工作方式

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/e8c43f33-5f27-1856-f4a3-0bd8ad4e023f.png)

整个配置化引擎最终对外暴露的就是一个渲染器组件，使用者以组件方式集成使用，渲染器组件接收一些必要的参数就能展开工作

其中，元数据参数比较重要，因为渲染器本身是没有任何内容的，页面长什么样子，支持什么联动交互都是交由元数据来指导

所以，配置化方案的基本思想就是：**用元数据来描述页面，以及页面组件间的联动关联关系**

那么，配置化方案设计的核心其实也在于：**元数据，而元数据又是由一个个元数据规则组合构成**

那么，配置化方案的实现过程其实就是围绕着元数据展开：**制定元数据规则、解析元数据规则**

元数据规则的制定影响着元数据长什么样子，影响着使用者如何使用这些规则配出他想要的效果，所以要尽量通俗、易配（因为对于业务组来说，很难有资源和精力去维护一个可视化平台，所以更多时候使用者需要直接面对元数据）

元数据规则的解析则是渲染器内部需要去实现的支撑能力，针对每一种规则，都需要有相应的能力去解析并响应。使用者不必关注这部分，但维护者需要，所以设计上可以尽量参考设计模式，让维护者比较方便扩展

### 元数据规则设计考量

那么，对于元数据的规则，都需要从哪几个方面来考量设计呢？

俗话说，麻雀虽小五脏俱全，虽然我们只是实现一个业务组使用的配置化渲染器，但也应该足以支撑日常开发中的各种页面交互场景的配置

所以，在考量元数据的规则场景时，我们应该从完整性角度出发，从上而下，从抽象到具体的来罗列我们所需的场景

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/04e873f1-f5af-f3c8-e58f-5e650c010f9e.png)

在没有配置化之前，开发一个页面我们需要写组件、写联动交互，直白说就是页面渲染和交互两方面的代码

那么，配置化之后，因为页面是通过元数据来描述了，所以元数据的规则同样需要包揽渲染和联动两方面

从这两个抽象角度出发再去细化各自的场景，元数据规则所需要考量的场景也就出来了

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/34add4d6-9c44-2066-acbe-2c20a438c671.png)

比如说，在渲染方面

可以预置一系列组件，直接供使用者配置使用，那么要让使用者可以基于这些预置组件配出各种页面效果，我们需要有通用的基础组件、排版布局的容器组件、以及复杂但公共的业务组件。这些预置组件的场景就会需要对应一套元数据的规则来解析并渲染

预置肯定有不满足的时候，所以一定要具备有让使用者自定义扩展的能力，这里就需要一套元数据规则来处理自定义组件的场景

渲染方面的场景比较少，不多说

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/9ffedae8-d50b-2f45-e7fd-73c016d2025c.png)

主要是组件的联动交互方面

如果在联动交互方面的支撑能力不够，那意味着使用者还是需要编写大量的交互代码

配置化也就只是用来配置 UI 渲染而已，那对于使用者来说，并不是很友好

所以在联动方面应该加大力度去思考，都应该设计哪些规则，支持哪些联动的交互配置

比如说联动交互的触发时机，基本分两种：事件、生命周期

比如说组件联动交互里一种改数据源的具体场景，数据源可以调接口获取、也可以是从表单上下文数据里获取、还可以是从数据仓库（store）获取、事件上下文数据里获取等等

再比如，组件的事件响应行为可以是改显隐、改样式、改文案等等各种各样的场景

再比如，有些取值逻辑或者事件响应行为是需要满足某种条件下才会执行，那意味着需要一套条件规则，而判断条件通过又需要依赖于表达式，所以也需要一套表达式规则

等等等等

在组件联动交互方面的场景会很多，所以在设计规则时还需要考量，规则的复用粒度

尽可能的设计出一些通用基本规则，对这些基本规则的组合使用后来满足以上的各种组件联动交互规则

比如表达式规则，就可以给条件规则用，也可以给数据源规则用等等

### 渲染器设计

规则设计好了，接下去就是解析规则的各种处理器的实现了

从单一职责角度出发，每一种处理器就只服务于该种场景下的元数据规则的解析

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/e7feb674-2f31-2e08-be36-53df0f3f7f5c.png)

首先渲染器接收整份元数据，所以需要有个元数据解析器，先来提取出元数据内各个数据，比如组件渲染的交给组件渲染去解析处理、事件的交给事件处理器等等

别看元数据规则制定时，考虑的场景很多

但实际上，解析的处理器并不会很多，因为元数据规则实际上就几种通用的，很多场景都是由多个基本规则组合拼装构成，对应的处理器只需要支持解析基本规则，然后多个处理器相互协作即可

这里简单罗列下基本处理器列表（其实也对应着元数据基本规则）：

- 元数据处理器
- 事件监听响应处理器
- 条件处理器
- 表达式处理器
- 数据源处理器
- 生命周期处理器

### 元数据规则示例

以上基本讲完了方案的设计思路，下面来举个实例讲解下，假如我们有这么个需求：

**点击**组件 A 时，满足 `formModel.a === 1` **条件**下，调用 `getA()` **接口**并**传参** `a=1` 来**刷新**组件 **A 列表**

这个交互上有这么几个关键点：

- 事件监听：点击事件

- 条件判断：全等表达式

- 取数：从表单模型里取字段 a

- 响应行为：调接口

- 取数：传参 a
- 响应行为：刷新列表
- 取数：A 列表数据源（ getA 调接口获取）

来看看我们用元数据怎么描述出这些信息来：

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/70d6c80d-e155-6635-2b30-8daa15dd06c0.png)

首先有一套事件监听规则，监听了点击事件

然后在事件响应时，有一段判断逻辑，所以这里需要有一套条件规则

条件里执行的是表达式，所以这里有一套表达式规则

表达式具体执行的是全等表达式，这个表达式就需要两个左右操作数

而操作数又需要一套数据源规则来描述如何取数

假如满足了条件，这时候执行响应行为，所以需要有一套事件响应规则

这里执行的行为是更新数据源，所以需要有一套数据源规则描述从哪取数

这里调接口取数，接口里又使用到参数，所以需要有参数规则

而参数里又涉及到取数，所以它依赖于数据源规则

这样下来，就通过元数据把整个组件的交互信息给描述出来了



如果你也接触过其他配置化框架，你会发现，大家的规则基本都不太一样，但解决的场景基本都一样

所以，我个人其实是认为，**元数据规则没有标准的说法，适用即可**

但可以多参考下热门框架的设计，毕竟他们是有经过用户在体验使用的

### 架构图

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/2ae542cd-de64-ab69-8c21-9c6e8d969a03.png)

当打开页面时，其实只有一个渲染器，渲染器内部此时会去拉取元数据，拿到元数据后，会先交给元数据解析器去解析

这个过程里，会先解读并提取出各种信息缓存以便后续使用

解析完后，丢给渲染器去把组件给渲染出来

然后等待用户交互，发生事件时，交由相关处理器去执行响应行为

整体就是这样一个流程



配置化方案设计的核心在于元数据规则的制定，但规则的制定大多是体现在使用文档上。具体到代码实现上时，反而是渲染器的实现

而渲染器是服务于元数据的，所以核心就是中央处理层的代码，包含了针对各种元数据规则解析的处理器

但整个配置化流程的闭环上，还需要与后端的交互、需要与用户的交互、需要数据的存储

所以方案设计完后，还需要设计整体的架构图

### 渲染器基本场景实现思路（QA）

**Q：如何直接渲染三方组件？**

- `<component :is>` + 自嵌

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/7d27064c-4377-597b-2255-e4376ee42329.png)

自嵌是为了支持类似 `el-select + el-option` 这种父子组件配套使用的场景

**Q：如何支持自定义组件？**

- 作用域插槽 slot + 布局位置处理

插槽可能使用多个，所以内部接收插槽后，需要有套规则来处理布局位置

使用作用域插槽则是提高扩展性，使用者可以自己在元数据上配置自己的规则，这些规则会原原本本丢给插槽组件，使用者拿到后自己去解析

支持这种用法意味着，当配置化预置的东西不满足时，使用者完全可以自己去定规则自己去实现

举个很实用的例子，比如当需要实现复杂的自定义组件，但不同租户间差别又很大，只能再重新开发一个组件时。这时候，不同租户就需要渲染不同的组件，此时就可以通过作用域插槽，自己定义组件的名称路径等信息，接收到这些规则时，自己去动态控制渲染哪个组件即可

**Q：如何处理业务对象（表单模型）建模？**

- 手动建模（天际-移动建模平台）

- 自动建模（超级表单、客服配置化表单）

自动建模时，需考虑复杂数据结构的场景，如多层内嵌，这时可以通过数据容器实现

**Q：如何提高配置化的扩展（自定义）能力？**

- 渲染：自定义组件
- 交互：自定义函数
- 其他：内置各种钩子

这其实只是站在业务组内部单就实现一个小型、完整的配置化渲染器角度去思考

如果想把配置化渲染器玩好，玩开源化，这就意味着使用者其实无法接触到源码，无法从源码层面去扩展、去改造

那么这时候，可以尝试借鉴 webpack 这类的思路，实现类似 plugin 插件的机制，让使用者有能力在配置化渲染器工作的各个过程中拦截和插入自己想要实现的功能

但其实，目前这个小型的配置化因为支持了自定义组件、函数、钩子的扩展方案，使用者已经可以实现在不同过程中拦截插入自己的实现。这与 plugin 思路不同的仅在于 plugin 是作用于全局，而钩子只作用于当前配置的页面

所以，目前的扩展能力已经可以很好的满足业务组在使用时的扩展需要了

**Q：如何支持自定义函数？**

- 注入函数库

- new Function

**Q：处理器的各种规则代码实现方案？**

- 抽象工厂模式

为了让维护者可以方便的扩展和维护，基于设计模式的开放-关闭原则，可以借助抽象工厂模式来实现对各种规则的代码维护

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/d99c96f4-5622-a49d-6d62-7a46021eda62.png)



### 平缓过度灰度开关方案

在没有配置化方案之前，实现个性化需求时，采用的是灰度开关方案

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/845a2e6e-9b5a-853d-24cc-75d12c81d04f.png)

这种方案的代码就一套，通过一个开关变量来控制不同页面渲染、组件联动交互的逻辑，最后再给不同租户开启或关闭这些开关

那么，如果该页面用配置化重构了，怎么能确保所有租户的个性化需求仍然存在呢？

这就涉及到元数据的维护方案了，正常的方案是：

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/333e5996-b884-c112-2b43-64ca1c0c15cc.png)

每个租户有一套自己的元数据

但这就意味着，我们重构这个页面时，需要整理出目前所有租户的一系列灰度开关状态，并根据这些灰度开关的不同组合即该租户的个性化需求，给这些租户配置不同的元数据

这种是最理想状态，因为这样一来租户间就不会相互影响

但这种方案的改造成本、工作量都太大了，我们没办法等到给所有租户都配完了元数据后才上线

虽然可以只上线配完的租户，其他租户仍旧使用老版，但这样的效果不是 PO 想要的效果，PO 自然是想要全租户都可以使用重构后的版本

所以一个性价比更高的方案就是，渲染器内部增加一个灰度开关解析器，这个会覆盖元数据上的某个配置项，简单说也就是元数据的部分配置是动态可根据其他条件变化的

这样一来，重构时，只需要配置一套标准元数据 + 灰度开关规则，所有租户就都可使用重构后版本，而且个性需求也在

但元数据里加灰度开关跟代码里加灰度开关控制没有什么本质上的区别，所以这只是一种过渡方案，用来平滑过渡

在这基础上，再来排期给不同租户配置不同元数据，配完一个就可上线一个

最终慢慢就能达到理想的元数据维护效果

### 配置化的可视化平台

![](https://kefu-zs.oss-cn-hangzhou.aliyuncs.com/ylys/demo/2021/12/06/d62f48ba-ada2-0249-8bb4-5732e3a42229.gif)

如果有资源和精力，可以实现一个配套的可视化平台来提高维护效率

但建议还是要了解元数据规则本身，毕竟这并不是一个复杂的配置化渲染器

### 配置化的优缺点

**优点：**

- 可以很好的支撑个性化需求开发
- 当预置规则足够丰富时，基本可以达到只需配置即可交付需求程度
- 当足够熟练时，可提高一定的开发效率
- 个性代码和标准代码界限明确、维护方便

**缺点：**

- 上手学习元数据规则成本较高
- 开发思维需要转变，从写代码转到元数据的配置上，需要一定适应成本
- 会丧失一定的灵活性
- 强依赖于配置化的渲染器，一旦内部制定的规则不满足时，就需要内部扩展支持，如果内部从本质上就无法扩展，此时将面临很大挑战

虽然配置化的方案存在挺多问题，但它带有的优点也一样很给力，尤其是当个性化需求积攒到一定程度时，配置化方案肯定是比灰度开关方案更适用

所以，是否选择使用配置化，哪些场景适合用配置化，都可以自己根据项目实际需要去评估



最后，看到这里了，可以翻到开头对着几个问题思考下，看下此时你心中是否对于每个问题都有答案了，那么也就基本了解了基于元数据的配置化方案的基本原理思想了

这样，及时你不想自己搭这个渲染器，你引入其他三方的配置化框架时，其实大家都大同小异，实现的功能和解决的问题基本都一样，那么基本也就没什么难题可以卡住你了